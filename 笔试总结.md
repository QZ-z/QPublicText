# 笔试

## 6.18深信服笔试

算法题

1. 删除字符串中连续出现大于等于3的字符[1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)
2. 碱基对（编辑距离）[72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
3. 路径处理（将含.和..等的路径优化到最简）[71. 简化路径](https://leetcode.cn/problems/simplify-path/)
4. 输入n行2列，第一列是值，第二列是上一个的位置，按照顺序输出

## 7.22浪潮笔试

题比较简单，15单选、5多选、10判断、1不定向、1简答

选择判断都是一些常见八股的试题版本

简答是实例化对象都有哪些方法

## 7.27oppo后端笔试

选择（2 * 20）加算法（20 * 3）

选择比较综合，各种类型都有，程序输出，linux概念指令，HTTP状态码，c++内联函数等，操作系统分段分页等

算法：

1. 给一个数组，看看有几个数二进制bit翻转之后比原来大（1101->1011）
2. 给两个01方阵，可以进行的操作是行或列取非，问两者相等的最少步数
3. 给一个带权树（编号从1开始），一个节点最多可以访问两次，问从1开始出发，获得的最大权重和是多少（一条边的权重只能加一次）

## 7.27讯飞Java开发工程师笔试

必做（选择、算法）和选做（选择题，三部分，java知识、sql知识、linux知识，根据方向自己选，这是java的）

关于分值，选择和算法好像是55开，没太注意

必做选择有树相关、操作系统相关、计网相关等

算法：

1. 白送，一个人每天积累A劳累值，干B天后休息，休息每天劳累值减1，问劳累值再次到1的天数
2. 问一个数的2~36进制中，bit1最多是多少
3. 给两个整数n和m，问由n个数构成的满足下列要求的序列a的数量，答案对$10^{9}+7$取模
   1. 序列a的值都属于[0, m]
   2. 序列a非递减
   3. 所有元素值异或为m

## 8.10美团

软件开发工程师-后端

10道选择，3算法

算法：

1. 给一个正确密码，和密码库（n个），从短到长一个个试，相同的只试一次，问最少和最多几次试出正确值
2. 给一个数组，可以进行两种操作：
   1. 删除第一个元素，代价是x
   2. 删除全部元素，代价是MEX(a)（数组中未出现的最小非负数）

​		问最小代价

3. 一个无限循环的彩带，每个位置有不同颜色，进行从左往右剪x或从右往左剪y的操作，问每次操作的颜色种类（$a_{i} = a_{i - n}$）

## 8.11大疆

单选5，不定向7，算法1（19分），附加1（分值很少，3分）

算法：

1. m*n的矩阵，每格有代价，正数表示加血，负数表示扣血，行动只能向右或向下，0血或者以下死亡，问从左上到右下的需要的最小初始血量

附加题：

1. 10亿图片，如何设计一个图像存储服务，能够很快的找出来里边的无人机图片。如何检索，可能的瓶颈有哪些，如何优化

```java
public static int calculateMinimumInitialPower(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];

        // 终点的初始电量要求
        dp[m-1][n-1] = Math.max(1, 1 - grid[m-1][n-1]);

        // 最后一列的电量要求
        for (int i = m - 2; i >= 0; i--) {
            dp[i][n-1] = Math.max(1, dp[i+1][n-1] - grid[i][n-1]);
        }

        // 最后一行的电量要求
        for (int j = n - 2; j >= 0; j--) {
            dp[m-1][j] = Math.max(1, dp[m-1][j+1] - grid[m-1][j]);
        }

        // 其余格子的电量要求
        for (int i = m - 2; i >= 0; i--) {
            for (int j = n - 2; j >= 0; j--) {
                int minPowerOnExit = Math.min(dp[i+1][j], dp[i][j+1]);
                dp[i][j] = Math.max(1, minPowerOnExit - grid[i][j]);
            }
        }

        // 返回起点所需的最小初始电量
        return dp[0][0];
    }
```

## 8.12 4399

## 8.14 用友
