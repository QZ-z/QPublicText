[toc]

### ==链表==

#### [环形链表2](https://leetcode.cn/problems/linked-list-cycle-ii/)	

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206231840000.png" alt="image-20231206231840000" style="zoom:50%;" />

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206231941434.png" alt="image-20231206231941434" style="zoom:50%;" />

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206232456936.png" alt="image-20231206232456936" style="zoom:50%;" />

> 注意：找到相遇节点之后，快慢指针都是一步一步走的

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206234417220.png" alt="image-20231206234417220" style="zoom:50%;" />

从最坏的情况开始算，当slow进入环的时候，fast正好在slow的前边，按照相对速度来看，这个时候fast需要走（环长-1）步才能和慢指针相遇，其他情况下走的步数都小于这种情况，所以相遇的时候，slow的移动距离小于环长

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        ListNode start = null;
        if(slow == null) return null;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast){
                start = slow;
                break;
            }
        }
        if(start == null) return start;
        slow = head;
        fast = start;
        while(slow != fast){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

#### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

[题解](https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l/?envType=study-plan-v2&envId=top-100-liked)

设A的长度为a，B的长度为b，两者的公共部分长度为c

一个指针先从A遍历，遍历完了之后再遍历B

另一个指针先从B开始遍历，遍历完了之后在遍历A

相遇时候A指针走过`a + (b - c)`B指针走过`b + (a - c)`

如果`c > 0`两者都指向相交节点，如果`c = 0` 两者都指向`null`

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode cur1 = headA, cur2 = headB;
        while(cur1 != cur2){
            cur1 = cur1 == null ? headB : cur1.next;
            cur2 = cur2 == null ? headA : cur2.next;
        }
        return cur1;

    }
}
```

#### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

学0x的简洁写法

[0x题解](https://leetcode.cn/problems/add-two-numbers/solutions/2327008/dong-hua-jian-ji-xie-fa-cong-di-gui-dao-oe0di/?envType=study-plan-v2&envId=top-100-liked)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(); // 哨兵节点
        ListNode cur = dummy;
        int carry = 0; // 进位
        while (l1 != null || l2 != null || carry != 0) { // 有一个不是空节点，或者还有进位，就继续迭代
            if (l1 != null) carry += l1.val; // 节点值和进位加在一起
            if (l2 != null) carry += l2.val; // 节点值和进位加在一起
            cur = cur.next = new ListNode(carry % 10); // 每个节点保存一个数位
            carry /= 10; // 新的进位
            if (l1 != null) l1 = l1.next; // 下一个节点
            if (l2 != null) l2 = l2.next; // 下一个节点
        }
        return dummy.next; // 哨兵节点的下一个节点就是头节点
    }
}

```

:clock1:待学习，递归版本

#### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

注意`dummy`节点的设置问题，有`dummy`节点后，删除问题不需要分情况考虑，很方便

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode slowDummy = new ListNode(0, head);
        ListNode slow = slowDummy, fast = slowDummy;

        while(fast != null && n-- > 0){
            fast = fast.next;
            
        }
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return slowDummy.next;
    }
}
```

#### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

一种直观的做法是使用最小堆，遍历所有链表的节点存入最小堆，之后不停取元素构建新链表，时间复杂度是$O(nlogn)$，其中n是所有节点的个数

优化：

- 当一个链表中的第一个节点被选为构建新链表的当前节点之后，下一个最小的节点，可以是该节点的下一个节点，也可以是其他链表中的第一个节点
- 即同一时间，最小堆中只需要保存等于链表数量的元素个数，这样处理，时间复杂度是$O(nlogk)$，其中k是链表的个数

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);
        ListNode dummy = new ListNode();
        ListNode tail = dummy;
        for(ListNode l : lists){
            if(l != null) pq.offer(l);
        }
        while(!pq.isEmpty()){
            ListNode node = pq.poll();
            tail.next = node;
            tail = node;
            if(node.next != null){
                pq.offer(node.next);
            }
        }
        return dummy.next;
    }
}
```

#### 反转链表

[0x视频讲解](https://www.bilibili.com/video/BV1sd4y1x7KN/?vd_source=f40328b81769fcf66b90a10650a067f0)

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

![image-20240715150947046](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240715150947046.png)

[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

![image-20240715150907783](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240715150907783.png)

之后p0更新为红色三角位置的节点

#### [LRU缓存](####146. LRU 缓存)

### ==双指针==

#### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

思路：移动高小的

正确性解释： 其实无论是移动短指针和长指针都是一种可行求解。 只是，一开始就已经把指针定义在两端，如果短指针不动，而把长指针向着另一端移动，两者的距离已经变小了，无论会不会遇到更高的指针，结果都只是以短的指针来进行计算。 故移动长指针是无意义的。

简单讲就是，为了求得更大值，移动长指针是无意义的

#### [接雨水](####【】[接雨水])

### ==栈==

#### [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

遇到左括号，入栈相应的右括号，这样，当遇到右括号的时候，比较是否和栈顶元素相等即可

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            //碰到左括号，就把相应的右括号入栈
            if (ch == '(') {
                deque.push(')');
            }else if (ch == '{') {
                deque.push('}');
            }else if (ch == '[') {
                deque.push(']');
            } else if (deque.isEmpty() || deque.peek() != ch) {
                return false;
            }else {//如果是右括号判断是否和栈顶元素匹配
                deque.pop();
            }
        }
        //最后判断栈中元素是否匹配
        return deque.isEmpty();
    }
}

```

### ==回溯==

#### 77 [组合](https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&envId=top-interview-150)

- [0x3f](https://leetcode.cn/problems/combinations/solutions/2071017/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-65lh/?envType=study-plan-v2&envId=top-interview-150)
- ==答案视角==

![image-20231016211228024](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016211228024.png)

![image-20231016213029676](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016213029676.png)

> 从大到小(即从后往前的顺序，`[1,i]`是待枚举的，`[i,n]`已经枚举过了)枚举，判断条件简单

```python []
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(i: int) -> None:
            d = k - len(path)  # 还要选 d 个数
            if d == 0:
                ans.append(path.copy())
                return
			'''
			当下边的循环使用for j in range(i,0,-1)的时候，在前用if判断
			if i < d :
				return
			'''

            for j in range(i, d - 1, -1):
                path.append(j)
                dfs(j - 1)
                path.pop()

        dfs(n)
        return ans
```
``` java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    public List<List<Integer>> combine(int n, int k) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        dfs(n,k);
        return paths;
    }
    public void dfs(int cur,int k){
        int d = k - path.size();
        if(d == 0){
            paths.add(new ArrayList<>(path));
            return;
        }
        //从[1,j]中进行选择，j应该>=d
        for(int j = cur;j > d-1 ;j--){
            path.add(j);
            dfs(j - 1,k);
            path.remove(path.size() - 1);
        }
    }
}
```

> 时间复杂度：分析回溯问题的时间复杂度，有一个通用公式：$路径长度\times搜索树的叶子数$。对于本题，它等于 $O(k\cdot C(n,k))$
> 空间复杂度：$O(k)$

- ==选与不选==

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(i: int) -> None:
            d = k - len(path)  # 还要选 d 个数
            if d == 0:
                ans.append(path.copy())
                return

            # 不选 i，只有i > d 才能不选i，否则不选之后加下来没有足够的数
            if i > d: dfs(i - 1)
            # 选 i
            path.append(i)
            dfs(i - 1)
            path.pop()
            
            '''
            if i < d :# 不够选
                return 
            dfs(i-1)

            path.append(i)
            dfs(i-1)
            path.pop()
            '''

        dfs(n)
        return ans
```

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    public List<List<Integer>> combine(int n, int k) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        dfs(n,k);
        return paths;
    }
    public void dfs(int cur,int k){
        int d = k - path.size();
        if(d == 0){
            paths.add(new ArrayList<>(path));//注意要新生成一个List
            return;
        }
        if(cur > d) dfs(cur - 1,k);

        path.add(cur);
        dfs(cur - 1,k);
        path.remove(path.size() - 1);
    }
}
```


#### 78 [子集](https://leetcode.cn/problems/subsets/description/)

- [0x3f](https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/)

- 每个位置选或不选

  ![image-20231016202952423](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016202952423.png)
  
  ![image-20231016203739240](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016203739240.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        ans = []
        path = []
        n = len(nums)
        def dfs(i: int) -> None:
            if i == n:
                ans.append(path.copy())  # 固定答案
                return
            # 不选 nums[i]
            dfs(i + 1)

            # 选 nums[i]
            path.append(nums[i])
            dfs(i + 1)
            path.pop()  # 恢复现场
        dfs(0)
        return ans
```

> 时间复杂度：$O(n2^{n})$，其中 n 为 $\textit{nums}$ 的长度。每次都是选或不选，递归次数为一个满二叉树的节点个数，那么一共会递归$O(2^{n})$次（等比数列和），再算上加入答案时需要 $O(n)$ 的时间（`path.copy()`），所以时间复杂度为 $O(n2^{n})$
>
> 空间复杂度：$O(n)$。返回值的空间不计。

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    public List<List<Integer>> subsets(int[] nums) {
        path = new ArrayList();
        paths = new ArrayList();
        this.nums = nums;
        dfs(0);
        return paths;
    }
    public void dfs(int i){
        if(i == this.nums.length){
            paths.add(new ArrayList(path));
            return;
        }
        dfs(i + 1);

        path.add(nums[i]);
        dfs(i + 1);
        path.remove(path.size() - 1);
    }
}
```

- 答案角度考虑

![image-20231016203255216](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016203255216.png)

![image-20231016203659438](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016203659438.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:d
        ans = []
        path = []
        n = len(nums)
        def dfs(i: int) -> None:
            ans.append(path.copy())  # 固定答案
            if i == n:
                return

            for j in range(i, n):  # 枚举选择的数字
                path.append(nums[j])
                dfs(j + 1)
                path.pop()  # 恢复现场
                
        dfs(0)
        return ans
```

> 时间复杂度：$O(n2^{n})$，其中 n 为 $\textit{nums}$ 的长度。答案的长度为子集的个数，即$2^{n}$，同时每次递归都把一个数组放入答案，因此会递归$2^{n}$次，再算上加入答案时需要${O(n)}$的时间，所以时间复杂度为$O(n2^{n})$
>
> 空间复杂度：$O(n)$。返回值的空间不计。

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    public List<List<Integer>> subsets(int[] nums) {
        path = new ArrayList();
        paths = new ArrayList();
        this.nums = nums;
        dfs(0);
        return paths;
    }
    public void dfs(int i){
        paths.add(new ArrayList(path));
        if(i == nums.length){
            return;
        }
        for(int j = i;j<nums.length;j++){
            path.add(nums[j]);
            dfs(j + 1);
            path.remove(path.size() - 1);
            
        }
    }
}
```

#### 131 [分割回文字串](https://leetcode.cn/problems/palindrome-partitioning/description/)

- [0x3f](https://leetcode.cn/problems/palindrome-partitioning/solutions/2059414/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-fues/)
- 选与不选（针对这个位置的逗号来说，假设每对相邻字符之间有个逗号，那么就看每个逗号是选还是不选）

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        path = []
        n = len(s)

        # start 表示当前这段回文子串的开始位置
        def dfs(i: int, start: int) -> None:
            if i == n:# i == n说明上一步（i=n-1）肯定是回文的要不不会往下dfs
                ans.append(path.copy())  # 复制 path
                return
            
            # 不选 i 和 i+1 之间的逗号（i=n-1 时一定要选）
            if i < n - 1:
                dfs(i + 1, start)

            # 选 i 和 i+1 之间的逗号（把 s[i] 作为子串的最后一个字符）
            t = s[start: i + 1]
            if t == t[::-1]:  # 判断是否回文
                path.append(t)
                dfs(i + 1, i + 1)  # 下一个子串从 i+1 开始
                path.pop()  # 恢复现场

        dfs(0, 0)
        return ans
```

```java
class Solution {
    List<String> path;
    List<List<String>> paths;
    String s;
    public List<List<String>> partition(String s) {
        path = new ArrayList();
        paths = new ArrayList();
        this.s = s;

        dfs(0,0,s.length());
        return paths;
    }
    public void dfs(int i,int start,int n){
        if(i == n){
            paths.add(new ArrayList(path));
            return;
        }
        if(i < n-1) dfs(i+1,start,n);

        String temp = s.substring(start,i+1);
        if (judge(temp)){
            path.add(temp);
            dfs(i +1,i + 1,n);
            path.remove(path.size() - 1);
        }


    }
    public boolean judge(String str){
        int n = str.length();
        int l = 0,r = n - 1;
        while(l <= r){
            if(str.charAt(l) != str.charAt(r)) return false;
            l++;
            r--;
        }
        return true;
    }
}
```

![image-20240112131354429](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112131354429.png)

- 答案视角

![image-20231016204958418](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231016204958418.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        path = []
        n = len(s)
        def dfs(i: int) -> None:
            if i == n:
                ans.append(path.copy())  # 复制 path
                return

            for j in range(i, n):  # 枚举子串的结束位置
                t = s[i: j + 1]
                if t == t[::-1]:  # 判断是否回文
                    path.append(t)
                    dfs(j + 1)
                    path.pop()  # 恢复现场

        dfs(0)
        return ans
```

```java
class Solution {
    List<String> path;
    List<List<String>> paths;
    String s;
    public List<List<String>> partition(String s) {
        path = new ArrayList();
        paths = new ArrayList();
        this.s = s;

        dfs(0,s.length());
        return paths;
    }
    public void dfs(int i,int n){
        if(i == n){
            paths.add(new ArrayList(path));
            return;
        }
        for(int j = i;j<n;j++){
            String temp = s.substring(i,j+1);
            if(judge(temp)){
                path.add(temp);
                dfs(j+1,n);
                path.remove(path.size() - 1);
            }
        }

    }
    public boolean judge(String str){
        int n = str.length();
        int l = 0,r = n - 1;
        while(l <= r){
            if(str.charAt(l) != str.charAt(r)) return false;
            l++;
            r--;
        }
        return true;
    }
}
```

![image-20240112131425040](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112131425040.png)

> 判断回文数可以优化
>
> 例如给定字符串`"abcda"`, 在已知`"bcd"`不是回文字串时, 不再需要去双指针操作`"abcda"`而可以直接判定它一定不是回文字串
>
> dp思想，给定一个字符串`s`, 长度为`n`, 它成为回文字串的充分必要条件是`s[0] == s[n-1]`且`s[1:n-1]`是回文字串。

#### :star:去重

有序选择和无序选择的去重策略不同

待补充

- ==有序==

 如果可以进行排序，生成有序数组，则可以使用`if(j > i && nums[j] == nums[j-1])`进行去重，排序之后，在当前层，选取的元素相同无意义，同时由于是有序的，只需要判断相邻的是否相等就可以

```java
for(int j = i;j < n; j ++){
            if(target - nums[j] < 0) return;
            if(j > i && nums[j] == nums[j-1]) continue;
            path.add(nums[j]);
            dfs(j +1,target - nums[j]);
            path.remove(path.size() - 1);
}
```

> 组合总和II和子集II中采用这种策略

- ==无序去重==

`used`数组，或者`set`集合

能使用`used`数组还是使用used数组，效率会高很多

```java
HashSet<Integer> set = new HashSet<>();
for(int j = 0;j < n;j++){
    if(!set.contains(nums[j]) && !used[j]){
        set.add(nums[j]);
        used[j] = true;
        path.add(nums[j]);
        sub(i+1,n);
        used[j] = false;
        path.remove(path.size() - 1);
    }
}
```

set集合放在这个位置，就是对当前层的去重，保证当前层选择的元素没有被选择过，如果能够排序，则与`if(j > i && nums[j] == nums[j-1])`完成的功能类似

[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)的两种层去重策略

- 利用排序

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        this.nums = nums;
        Arrays.sort(nums);
        int n = nums.length;
        used = new boolean[n];
        sub(0,n);
        return paths;
    }
    public void sub(int i,int n){
        if(i == n){
            paths.add(new ArrayList(path));
            return;
        }
        for(int j = 0;j < n;j++){
            if(used[j]) continue;
            if(j > 0 && nums[j] == nums[j-1] && used[j -1] == false) continue;            
            used[j] = true;
            path.add(nums[j]);
            sub(i+1,n);
            used[j] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

> 这种情况下需要注意设定`used[j - 1] == false`，因为相对于组合问题，排列问题是有序的，组合的无序问题，可以保证之前的已经全部被选了（或者是要被剪去的枝）
>
>  在一个for中，如果`nums[j] == nums[j - 1]`，但是`used[j - 1] == false`，说明这个值已经选过了，此时`used`是经历完递归恢复栈之后的`used`数组了，是在一层上去重
>
> 如果写为`used[j-1] == true`那么证明此时已经走到下一层了，`used[j-1]`已经在上边的层选过了，是在树枝上去重

- 使用set

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        this.nums = nums;
        int n = nums.length;
        used = new boolean[n];
        sub(0,n);
        return paths;
    }
    public void sub(int i,int n){
        if(i == n){
            paths.add(new ArrayList(path));
            return;
        }
        HashSet<Integer> set = new HashSet<>();
        for(int j = 0;j < n;j++){
            if(!set.contains(nums[j]) && !used[j]){
                set.add(nums[j]);
                used[j] = true;
                path.add(nums[j]);
                sub(i+1,n);
                used[j] = false;
                path.remove(path.size() - 1);
            }
        }
    }
}
```

#### 【10.18】[N皇后](https://leetcode.cn/problems/n-queens/description/)

![image-20231018145521553](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231018145521553.png)

- 都是保存的列信息之后生成矩阵，可以继续尝试直接用矩阵存储（用空间换时间）

#### :star: 从全排列分析时间复杂度

![image-20231017230225243](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231017230225243.png)

- 递归的调用次数为$ \sum_{m=0}^{n}A_{n}^{m} = n!\times(\frac{1}{0!}+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+...+\frac{1}{n!}) < e\times n!$，所以递归的调用是$O(n!)$量级

  > $e = \sum_{k=0}^{+\infty}\frac{1}{k!}$

- 简单的算法是从倒数第二排开始算，该排有$n!$个节点，其上层有$\frac{n!}{2}$个，再上上层可以视作$\frac{n!}{4}$个 （ 实际上越往上分叉越多，节点越少，实际上算的是一个上届），上界总和：$n!\times (1+\frac{1}{2}+...+\frac{1}{2^n}) < n!\times\sum_{n=0}^{\infty}\frac{1}{2^n} = 2\times n!$，再加上最后一层的$n!$总共的上界为$3\times n!$
- **最终加上copy的复杂度为$O(n\times n!)$**
- 空间复杂度为$O(n)$

- 按照图中的就是$A_{3}^{0}+A_{3}^{1}+A_{3}^{2}+A_{3}^{3}$

![image-20231017233622520](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231017233622520.png)

#### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

candidates中的数可以多选，但其中的数各不相同

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] candidates;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {        
        path = new ArrayList<>();
        paths = new ArrayList<>();
        this.candidates = candidates;
        dfs(0,target);
        return paths;
    }
    public void dfs(int i,int target){
        if(target == 0){
            paths.add(new ArrayList<>(path));
            return;
        }
        if(target < 0) return;
        for(int j = i;j < candidates.length; j ++){
             
            path.add(candidates[j]);
            dfs(j,target - candidates[j]);
            path.remove(path.size() - 1);
        }
    }
}
```

上述答案candidates是无序的，如`[11,2,3,5]`，不方便剪枝

可以对candidates进行排序之后剪枝，如果上边的数组有序则为`[2,3,5,11]`，对于当前路径sum+candidates[j]已经大于target的情况，之后的j就都不需要遍历了

```java
//剪枝
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] candidates;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {        
        path = new ArrayList<>();
        paths = new ArrayList<>();
        this.candidates = candidates;
        Arrays.sort(this.candidates);//排序为了之后的剪枝
        dfs(0,target);
        return paths;
    }
    public void dfs(int i,int target){
        if(target == 0){
            paths.add(new ArrayList<>(path));
            return;
        }
        for(int j = i;j < candidates.length; j ++){
            if(target - candidates[j] < 0) return;//现在的退出放在这里
            path.add(candidates[j]);
            dfs(j,target - candidates[j]);
            path.remove(path.size() - 1);
        }
    }
}
```

#### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

candidates中的每个数只能选一次，但candidates中的数可能会有重复

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] candidates;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        this.candidates = candidates;
        Arrays.sort(this.candidates);
        dfs(0,target);
        return paths;
    }
    public void dfs(int i,int target){
        if(target == 0){
            paths.add(new ArrayList<>(path));
            return;
        }
        
        for(int j = i;j < candidates.length; j ++){
            if(target - candidates[j] < 0) return;
            if(j > i && candidates[j] == candidates[j-1]) continue;
            path.add(candidates[j]);
            dfs(j +1,target - candidates[j]);
            path.remove(path.size() - 1);
        }
    }
}
```

#### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

- 每个数只能选一次

答案视角考虑

- 可以每次改变参数值k，这样就没必要每次开头计算`int d = k - path.size()`

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    public List<List<Integer>> combinationSum3(int k, int n) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        dfs(9,k,n);
        return paths;
    }
    public void dfs(int i,int k,int n){
        int d = k - path.size();
        if(d == 0){
            if(n == 0) paths.add(new ArrayList<>(path));
            return;
        }
        for(int j = i;j >= d;j--){
            path.add(j);
            dfs(j-1,k,n-j);
            path.remove(path.size() - 1);
        }
    }
}
```

选或不选

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    public List<List<Integer>> combinationSum3(int k, int n) {
        path = new ArrayList<>();
        paths = new ArrayList<>();
        dfs(9,k,n);
        return paths;
    }
    public void dfs(int i,int k,int n){
        int d = k - path.size();
        if(d == 0){
            if(n == 0) paths.add(new ArrayList<>(path));
            return;
        }
        if(i > d) dfs(i-1,k,n);
        path.add(i);
        dfs(i-1,k,n-i);
        path.remove(path.size() - 1);
    }
}
```

#### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

回溯，答案视角考虑

```java
class Solution {
    List<String> res;
    StringBuilder sb;
    Map<String, String> map = new HashMap<String, String>(Map.of("2","abc", "3", "def",
    "4","ghi","5","jkl","6","mno","7","pqrs","8","tuv","9","wxyz"));
    char[] digits_array;
    public List<String> letterCombinations(String digits) {
        digits_array = digits.toCharArray();
        if(digits_array.length == 0) return new ArrayList<String>();
        res = new ArrayList<>();
        sb = new StringBuilder();
        dfs(0);
        return res;

    }
    public void dfs(int i){
        if(i == digits_array.length){
            res.add(new String(sb));
            return;
        }
        char[] temp = map.get(String.valueOf(digits_array[i])).toCharArray();
        for(int j = 0;j<temp.length;j++){
            sb.append(temp[j]);
            dfs(i + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```

队列

使用队列，先将输入的 digits 中第一个数字对应的每一个字母入队，然后将出队的元素与第二个数字对应的每一个字母组合后入队...直到遍历到 digits 的结尾。最后队列中的元素就是所求结果。

![image-20240103170043350](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240103170043350.png)

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        res = collections.deque()
        phoneMap = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz",
        }

        for num in digits:
            size = len(res)
            if size == 0:
                for char in phoneMap[num]:
                    res.append(char)
            while size > 0:
                cur = res.popleft()
                for char in phoneMap[num]:
                    new  =cur + char
                    res.append(new)

                size -= 1

        
        return list(res)

```

#### [2397. 被列覆盖的最多行数](https://leetcode.cn/problems/maximum-rows-covered-by-columns/)

回溯生成选择各列的情况，然后一行一行对比

优化：如何采用位运算的方法进行优化

```java
class Solution {
    List<List<Integer>> masks;
    List<Integer> mask;
    public int maximumRows(int[][] matrix, int numSelect) {
        //位运算，先或再异或
        int col = matrix[0].length;
        masks = new ArrayList<>();
        mask = new ArrayList<>();
        //在col位0中生成numsSelect个1，回溯？
        int res = 0;
        dfs(col,numSelect);
        for(List l : masks){
            int temp = 0;
            for(int i = 0;i<matrix.length;i++){
                boolean flag = true;
                for(int j = 0;j<col;j++){
                    if(matrix[i][j] == 1 && (int)l.get(j) == 0){
                        flag = false;
                        break;
                    } 
                }
                if(flag) temp++;
            }
            res= Math.max(temp,res);
        }
        return res;
    }
    public void dfs(int i,int numSelect){        
        if(i == 0){
            if(numSelect == 0) masks.add(new ArrayList(mask));
            return;
        }
        //还可以选i+1
        if(i +1 > numSelect) {
            mask.add(0);
            dfs(i - 1,numSelect);
            mask.remove(mask.size() - 1);
        }
        mask.add(1);
        dfs(i - 1,numSelect - 1);
        mask.remove(mask.size() - 1);

        
    }
}
```

#### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

类似分割回文字串，但判断条件比较复杂

- 必须分成4块
- 每块整数不是0的话不能以0开头
- 正数不大于255

:one:选或不选（针对分割符号）

```java
class Solution {
    List<String> path;
    List<String> paths;
    String s;
    public List<String> restoreIpAddresses(String s) {
        path = new ArrayList();
        paths = new ArrayList();
        this.s = s;

        dfs(0,0,s.length());
        return paths;
    }
    public void dfs(int i,int start,int n){
        if(path.size() > 4) return;
        if(i == n){
            if(path.size() == 4){
                StringBuilder sb = new StringBuilder();
                for(String str:path){
                    sb.append(str);
                    sb.append(".");
                }
                sb.deleteCharAt(sb.length() - 1);
                paths.add(sb.toString());
            }
            return;
        }
        // String temp = s.substring(start,i+1);
        // if(i - start == 2 && !judge(temp)) return;
        if(i < n-1 && i - start < 2) dfs(i+1,start,n);//255最多3位，如果当前没满3位了，才能不选

        String temp = s.substring(start,i+1);
        if (judge(temp)){
            path.add(temp);
            dfs(i +1,i + 1,n);
            path.remove(path.size() - 1);
        }else{
            if(i - start == 2) return;
        }
    }
    public boolean judge(String str){
        // if(str.length() > 1 && str.charAt(0) == '0'){
        //      return false;
        // }
        // if(Integer.valueOf(str) > 255){
        //     return false;
        // }
        // return true;

        return !(str.length() > 1 && str.charAt(0) == '0') && !(Integer.valueOf(str) > 255);
    }
}
```

:two:答案视角

```java
class Solution {
    List<String> path;
    List<String> paths;
    String s;
    public List<String> restoreIpAddresses(String s) {
        path = new ArrayList();
        paths = new ArrayList();
        this.s = s;

        dfs(0,s.length());
        return paths;
    }
    public void dfs(int i,int n){
        if(path.size() > 4) return;
        if(i == n){
            if(path.size() == 4){
                StringBuilder sb = new StringBuilder();
                for(String str:path){
                    sb.append(str);
                    sb.append(".");
                }
                sb.deleteCharAt(sb.length() - 1);
                paths.add(sb.toString());
            }
            return;
        }

        for(int j = i;j <i + 3 && j < n;j++){
            String temp = s.substring(i,j+1);
            if(judge(temp)){
                path.add(temp);
                dfs(j +1,n);
                path.remove(path.size() - 1);    
            }
        }
    }
    public boolean judge(String str){
        return !(str.length() > 1 && str.charAt(0) == '0') && !(Integer.valueOf(str) > 255);
    }
}
```

#### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

类似[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)的去重

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        path = new ArrayList();
        paths = new ArrayList();
        this.nums = nums;
        Arrays.sort(this.nums);
        dfs(0,nums.length);
        return paths;
    }
    public void dfs(int i,int n){
        paths.add(new ArrayList(path));
        if(i == n){
            return;
        }
        for(int j = i;j <n;j++){
            if(j > i && nums[j] == nums[j-1]) continue;
            path.add(nums[j]);
            dfs(j+1,n);
            path.remove(path.size() - 1);
        }
    }
}
```

#### [491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

```java
class Solution {
    List<Integer> path;
    List<List<Integer>> paths;
    int[] nums;
    public List<List<Integer>> findSubsequences(int[] nums) {
        path = new ArrayList();
        paths = new ArrayList();
        this.nums = nums;
        dfs(0,nums.length);
        return paths;
    }

    public void dfs(int i, int n){
        if(path.size() >= 2){
            paths.add(new ArrayList(path));
        }
        Set<Integer> set = new HashSet<>();
        for(int j = i;j < n;j++){
            if(set.contains(nums[j]) || 
            (path.size() > 0 && path.get(path.size() - 1) > nums[j])) continue;

            set.add(nums[j]);
            path.add(nums[j]);
            dfs(j+1,n);
            path.remove(path.size() - 1);
        }
    }
}

```

### ==贪心==

#### 【10.18】[分发饼干](https://leetcode.cn/problems/assign-cookies/description/)

#### 【10.18】[摆动序列](https://leetcode.cn/problems/wiggle-subsequence/description/)

- 找峰和谷：`prediff`和`curdiff`相异

  ![image-20231018194905328](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231018194905328.png)

如上图所示的情况使得`prediff`的不等号可以取0

![image-20231018195547788](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231018195547788.png)

遇到相同数的时候，保留最右边的，使得`prediff`可以取等号

![image-20231018195037219](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231018195037219.png)

如上图所示的情况，当元素相同时或者和峰的上一个还是峰，则不更新prediff，只在峰找到谷的时候更新prediff

上图摆动序列长度实际为2

> prediff只需要符号信息即可，值无所谓

#### 【10.18】[最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

- 贪心和dp都可以
- **贪心的思路为**
  - **局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。**
  - **从而推出全局最优：选取最大“连续和”**

#### 【10.18】[买卖股票的最佳时机II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

#### 【10.18】[跳跃游戏](https://leetcode.cn/problems/jump-game/description/)

#### 【10.19】[同积元组](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

#### 【10.19】[跳跃游戏II](https://leetcode.cn/problems/jump-game-ii/description/)

#### 【10.19】[K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

#### 【10.19】[加油站](https://leetcode.cn/problems/gas-station/)

#### 【10.19】[柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

#### 【10.20】[根据规则将箱子分类](https://leetcode.cn/problems/categorize-box-according-to-criteria/)

#### 【10.20】[分发糖果](https://leetcode.cn/problems/candy/)

- 左边右边单独考虑

#### 【10.20】[根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

#### 【10.20】[用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

#### 【10.20】[无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

#### 【10.20】[划分字母区间](https://leetcode.cn/problems/partition-labels/)

#### 【10.21】[统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)

#### 【10.22】[做菜顺序](https://leetcode.cn/problems/reducing-dishes/)

- 递推关系式
- 了解价格高的菜，先做还是后做收益更高
- 排序从高到低，但是最左边的菜是后做的（价格高的菜后做更赚）

#### 【10.22】[单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

- 233332，记录最左边的最大值3，等发生`str[i-1] > str[i]`的时候，记录的位置减1，后面的位数都置9

> 实际的操作是在`str[i-1] > str[i]`的地方`str[i-1]-1`然后`str[i]`置为9，但这样`str[i-2]>str[i-1]`需要不停得再向前操作，所以记录最左边的位置，方便操作

- 233333，记录的最大位置为3，但是未发生`str[i-1] > str[i]`所以遍历完就结束了
- 243332，记录的位置和第一次发生`str[i-1] > str[i]`的位置相同，直接在这个位置进行相关操作

### ==**动态规划**==

#### 【10.22】[监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

- [0x3f视频](https://www.bilibili.com/video/BV1oF411U7qL/?buvid=XYE3EE4E9D39DAE1F344579EF09E8FEC87594&is_story_h5=false&mid=zoB%2FPYxsFRVrBrgkb6GfrQ%3D%3D&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=1f4d343f-deb0-41b4-ae74-3748a7a8920e&share_source=COPY&share_tag=s_i&timestamp=1695286897&unique_k=4jlshnk&up_id=206214&vd_source=f40328b81769fcf66b90a10650a067f0)
- [0x3f题解](https://leetcode.cn/problems/binary-tree-cameras/solutions/2452795/shi-pin-ru-he-si-kao-shu-xing-dpgai-chen-uqsf/)

![image-20231022205930830](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022205930830.png)

![image-20231022210040510](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022210040510.png)

![image-20231022210141936](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022210141936.png)

> 蓝色节点已经安装了摄像头，所以不用子树什么颜色都可以

**<font size = 5 color= blue>蓝色= min（左蓝，左黄，左红）+ min（左蓝，左黄，左红）+ 1</font>**

**<font size=5 color=orange>黄色 = min（左蓝，左红） + min（右蓝，右红）</font>**

> 黄色节点的儿子不可能是黄色

**<font size=5 color=red>红色 = min（左蓝+右红，左红+右蓝，左蓝+右蓝）</font>**

> 红色节点的儿子不可能是黄色，且至少有一个是蓝色

 ![image-20231022212825818](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022212825818.png) 

```python
class Solution:
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            if node is None:
                return inf, 0, 0  # 空节点不能安装摄像头，也无需被监控到
            l_choose, l_by_fa, l_by_children = dfs(node.left)
            r_choose, r_by_fa, r_by_children = dfs(node.right)
            choose = min(l_choose, l_by_fa,l_by_children) + min(r_choose, r_by_fa, r_by_children) + 1
            by_fa = min(l_choose, l_by_children) + min(r_choose, r_by_children)
            by_children = min(l_choose + r_by_children, l_by_children + r_choose, l_choose + r_choose)
            return choose, by_fa, by_children
        choose, _, by_children = dfs(root)  # 根节点没有父节点
        return min(choose, by_children)
```

![image-20231022213520555](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022213520555.png)

##### 扩展

![image-20231022213845576](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022213845576.png)

- 上边的题相当于所有cost都是1，修改只需要修改`choose = min(l_choose, l_by_fa,l_by_children) + min(r_choose, r_by_fa, r_by_children) + 1`中的1为cost[x]即可

![image-20231022214005969](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022214005969.png)

![image-20231022214022787](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022214022787.png)

- 枚举情况过多，所以可以化简红色的式子
- 对于三个儿子的情况，如果没有至少有一个蓝儿子的要求，那么公式变更为$红色 = min(蓝1，红1)+min(蓝2，红2)+min(蓝3，红3)$

> 这个和算黄色的式子相同

- 上述两式不相等的情况为：==所有的红色都比蓝色要小，这样就不会选择蓝色==
- 对于$min(5,2) + min(7,6) + min(5,1)$来说，将一个**红色减去蓝色最小**的点修改之后，即满足的至少有一个蓝儿子的要求，也使得最终的结果尽量小，需要注意的是如果一开始所有的$\text{蓝色}-红色>=0$那么就不需要修改了
- **最后的式子为:**

![image-20231022215315571](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231022215315571.png)

- 红色式子更新之后，进一步说明**红色一定>=黄色**，所有可以将蓝色的式子一并更新

#### 【】[打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

- 树形dp

#### 【10.22】[斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

#### 【10.22】[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

#### 【10.22】[使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

#### 【10.23e1p】[老人的数目](https://leetcode.cn/problems/number-of-senior-citizens/)

#### 【】[不同路径](https://leetcode.cn/problems/unique-paths/)

#### 【】[不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

#### 【】[整数拆分](https://leetcode.cn/problems/integer-break/)

#### 【】[不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

- dp[i]表示：i个不同元素节点组成的二叉搜索树的个数
- $dp[i] = \sum_{j = 1}^{j = i}dp[j-1]*dp[i-j]$

- 不必过于关注各个点都是多少，实际上，只要有三个不相同的数，组成的几种二叉搜索树的形状都那几样

![image-20231023205212648](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231023205212648.png)

- 即使数字不是`1,2,3`树的形状也是这几种
- 选定一个根，因为数组是`1到n`，那么左右子树的节点数量也就确定了

#### 【10.24e1p】[掷骰子等于目标和的方法数](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/)

- `dp = [[0] * (target-n+1)] * (n + 1)`这种初始化不正确，初始化后每行的地址相同，修改`dp[0][0]`,`dp[1][0]`也会变化
- 应采用这种初始化方法`dp = [[0] * (target - n + 1) for _ in range(n + 1)]`

#### ==【要长脑子了】01背包和完全背包==

- [0x3f视频](https://www.bilibili.com/video/BV16Y411v7Y6/?p=18&spm_id_from=pageDriver)

![image-20231024204346146](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024204346146.png)

- 记忆化搜索

![image-20231024205130594](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024205130594.png)

##### [目标和](https://leetcode.cn/problems/target-sum/)

- [0x3f题解](https://leetcode.cn/problems/target-sum/solutions/2119041/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-s1cx/)

- s为nums的和，正数和p，负数和$-(s-p)$
- 正负数总和$2p-s = t$，有$p = (s+t)/2$
- 即p需要满足这个条件，那么s+t不能是奇数，也不能是负数
- $dfs(i,t) = dfs(i-1,t) + dfs(i-1,t-nums[i])$
- `dfs(i,t)`的含义：在容量还为t的时候在前i个选择的不同表达式数目

###### 递归+记忆化搜索

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        target += sum(nums) 
        if target < 0 or target % 2:
            return 0
        target //= 2
        @cache
        def dfs(i,t):
            if i < 0:
                return 1 if t == 0 else 0 
            if t < nums[i]: # 可能当前的并不能选
                return dfs(i-1,t)
            return dfs(i-1,t) + dfs(i-1,t-nums[i])

        return dfs(len(nums)-1,target)
```

![image-20231024205748289](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024205748289.png)

###### 动态规划

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        target += sum(nums) 
        if target < 0 or target % 2:
            return 0
        target //= 2

        n = len(nums)
        dp = [[0] * (target+1) for _ in range(n+1)]
        dp[0][0] = 1

        for i in range(1,n+1):
            for j in range(target+1):
                # 注意因为循环从1,到n，所以这里操作的数是nums[i-1]，循环改为从0到n-1，操作的数变为nums[i]
                if nums[i-1] > j:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]

        # 两种递归的方式不同
        # for i in range(n):
        #     for j in range(target+1):
        #         if nums[i] > j:
        #             dp[i+1][j] = dp[i][j]
        #         else:
        #             dp[i+1][j] = dp[i][j] + dp[i][j-nums[i]]

        return dp[n][target]
```

![image-20231024205953841](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024205953841.png)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        target += Arrays.stream(nums).sum();
        // System.out.println(target);
        if(target < 0 || target % 2 != 0) return 0;
        target /= 2;
        int[][] dp = new int[n+1][target+1];
        dp[0][0] = 1;
        for(int i = 1;i<=n;i++){
            for(int j = 0;j<=target;j++){
                if(nums[i - 1] > j){
                    dp[i][j] = dp[i-1][j];//dp[1][0] = dp[0][0]
                }else{
                    dp[i][j] = dp[i-1][j] + dp[i-1][j - nums[i-1]];    
                    
                }
            }
        }
        return dp[n][target];
    }
}
```

###### 滚动数组优化动态规划空间（两个数组）

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        target += sum(nums) 
        if target < 0 or target % 2:
            return 0
        target //= 2
           
        n = len(nums)
        dp = [[0] * (target+1) for _ in range(2)]        
        dp[0][0] = 1

        for i in range(1,n+1):
            for j in range(target+1):
                if nums[i-1] > j:
                    dp[i%2][j] = dp[(i-1)%2][j]
                else:
                    dp[i%2][j] = dp[(i-1)%2][j] + dp[(i-1)%2][j-nums[i-1]]

        return dp[n%2][target]
```

![image-20231024210147346](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024210147346.png)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        target += Arrays.stream(nums).sum();
        // System.out.println(target);
        if(target < 0 || target % 2 != 0) return 0;
        target /= 2;
        int[][] dp = new int[2][target+1];
        dp[0][0] = 1;
        for(int i = 1;i<=n;i++){
            for(int j = 0;j<=target;j++){
                if(nums[i - 1] > j){
                    dp[i % 2][j] = dp[(i-1) % 2][j];//dp[1][0] = dp[0][0]
                }else{
                    dp[i % 2][j] = dp[(i-1) % 2][j] + dp[(i-1) % 2][j - nums[i-1]];
                }
            }
        }
        return dp[n%2][target];
    }
}
```

###### 一个数组优化动态规划空间

<img src="http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024211011499.png" alt="image-20231024211011499" style="zoom: 33%;" />

- 对于红色位置的数据，它的更新需要绿色箭头的位置的数据，那么从前往后的，则会导致后边的数据出现问题，所以采用从前向后的方法处理

> 从前往后，前边的数据被更新了，计算后边要用的是之前的数据，而不是更新之后的

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        target += sum(nums) 
        if target < 0 or target % 2:
            return 0
        target //= 2

        n = len(nums)
        dp = [0] * (target+1)
        dp[0] = 1

        for i in range(1,n+1):
            for j in range(target,-1,-1):
                if nums[i-1] > j:
                    dp[j] = dp[j]
                else:
                    dp[j] = dp[j] + dp[j-nums[i-1]]
        '''
        注意到当nums[i-1] > j的时候，并未更新，所以我们可以缩小j遍历的范围
        for i in range(1,n+1):
            for j in range(target,nums[i-1]-1,-1):
				dp[j] = dp[j] + dp[j-nums[i-1]]
        '''
        return dp[target]
```

![image-20231024210234911](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024210234911.png)

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int n = nums.length;
        target += Arrays.stream(nums).sum();
        // System.out.println(target);
        if(target < 0 || target % 2 != 0) return 0;
        target /= 2;
        int[] dp = new int[target+1];
        dp[0] = 1;
        for(int i = 1;i<=n;i++){
            for(int j = target;j>=nums[i-1];j--){
                dp[j] = dp[j] + dp[j - nums[i-1]];
            }
        }
        return dp[target];
    }
}
```

#### ==完全背包==

![image-20231024223211100](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231024223211100.png)

##### [零钱兑换](https://leetcode.cn/problems/coin-change/description/)


- [0x3f题解](https://leetcode.cn/problems/coin-change/solutions/2119065/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-21m5/)

###### 递归+记忆化搜索

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dfs(i,t) = min(dfs(i-1,t), dfs(i,t-coins[i])+1)
        n = len(coins)
        
        @cache
        def dfs(i,t):
            if i < 0:
                return 0 if t == 0 else inf
            if coins[i] > t :
                return dfs(i-1,t)
            return min(dfs(i-1,t),dfs(i,t-coins[i])+1)
        
        ans = dfs(n-1,amount)
        return ans if ans < inf else -1
```

![image-20231025153346406](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231025153346406.png)

###### 动态规划

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] dp =  new int[n+1][amount+1];
        Arrays.fill(dp[0], Integer.MAX_VALUE/2);
        dp[0][0] = 0;
        for(int i = 1;i<=n;i++){
            for(int j = 0;j<=amount;j++){
                if(j >= coins[i - 1]){
                    dp[i][j] = Math.min(dp[i-1][j], dp[i][j - coins[i-1]] + 1);
                }else{
                    dp[i][j] = dp[i - 1][j];
                }       
            }
        }
        return (dp[n][amount] == Integer.MAX_VALUE/2) ? - 1:dp[n][amount];
    }
}
```

###### 动态规划（一个数组）

<img src="http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231025150653925.png" alt="image-20231025150653925" style="zoom:50%;" />

- 红色位置的值需要箭头指向位置的值，所以需要从前往后计算，有别与01背包目标和的从后往前遍历

> 因为计算当前值，需要`i+1`行先于当前位置的值，所以要从前往后计算，先算出这些值

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dfs(i,t) = min(dfs(i-1,t), dfs(i,t-coins[i])+1)
        n = len(coins)
        
        dp = [inf] * (amount+1)
        dp[0] = 0
        for i in range(1,n+1):
            for j in range(coins[i-1],amount+1): # 从前向后
                # dp[i][j] = min(dp[i-1][j],dp[i][j-conis[i-1]+1])
                dp[j] = min(dp[j],dp[j-coins[i-1]] + 1) 
        
        return dp[amount] if dp[amount] < inf else -1
```

![image-20231025153358829](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231025153358829.png)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[] dp =  new int[amount+1];
        Arrays.fill(dp, Integer.MAX_VALUE/2);
        dp[0] = 0;
        for(int i = 1;i<=n;i++){
            for(int j = coins[i-1];j <= amount;j++){
                dp[j] = Math.min(dp[j], dp[j - coins[i-1]] + 1);
            }
        }
        return (dp[amount] < Integer.MAX_VALUE/2) ? dp[amount] : - 1;
    }
}
```

#### 【10.25e1p】[求一个整数的惩罚数](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/)

![image-20231025201554085](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231025201554085.png)

- 关于$O(2^{m})=O(i^{2log_{10}2})$的证明：
- $O(2^{m})= O(2^{2log_{10}i}) = O((2^{log_{10}i})^{2}) = O((e^{ln2\frac{lni}{ln10}})^{2})=O((i^{\frac{ln2}{ln10}})^{2})=O((i^{log_{10}2})^{2})=O(i^{2log_{10}2})$

#### 【10.26e1p】[统计能整除数字的位数](https://leetcode.cn/problems/count-the-digits-that-divide-a-number/)

#### 【】[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

对半分，那么总和一定是偶数，然后两个子集的和都是总和的一半

```java
class Solution {
    public boolean canPartition(int[] nums) {
        //01背包问题
        int sum = Arrays.stream(nums).sum();
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int n = nums.length;
        boolean[][] dp = new boolean[n + 1][target + 1];
        dp[0][0] = true;
        for(int i = 1;i<=n;i++){
            for(int j = 0;j <= target; j++){
                if(dp[i-1][j] || (j - nums[i-1] >= 0 &&dp[i-1][j - nums[i-1]])){
                    dp[i][j] = true;
                }
            }
        }
        return dp[n][target];
    }
}
```

#### 【】[最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

- [参考解](https://leetcode.cn/problems/last-stone-weight-ii/solutions/2288688/ling-shen-0-1bei-bao-cong-ji-yi-hua-sou-dq5vl/)

  ![image-20231026144352875](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231026144352875.png)

#### 【】[一和零](https://leetcode.cn/problems/ones-and-zeroes/)

- 多维背包

#### 【】[零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

- [零钱兑换](https://leetcode.cn/problems/coin-change/description/)只是求能不能，2是求方案数量

#### 【】[组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

- 采用类似爬楼梯的思考，爬到i的方案dp[i]，为可以从i-1到i,i-2到i

#### 【10.27e1p】[切割后面积最大的蛋糕](https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/)

#### 【10.28e1p】[从数量最多的堆取走礼物](https://leetcode.cn/problems/take-gifts-from-the-richest-pile/)

#### 【】[完全平方数](https://leetcode.cn/problems/perfect-squares/)

- 转化为完全背包问题
- 主要是分清楚，`dp[i][j]`中的i和j代表什么
- j表示目标和，`i * i`表示可供选择的背包中的数

#### 【10.29e1p】[H 指数](https://leetcode.cn/problems/h-index/)

- [0x3f计数题解](https://leetcode.cn/problems/h-index/solutions/2502837/mei-kan-dong-ti-yi-yi-zhang-tu-miao-dong-8zps/?envType=daily-question&envId=2023-10-29)

#### 【】[H 指数 II](https://leetcode.cn/problems/h-index-ii/)

- 二分迷，为啥是n-mid不是n-mid +1，额，最后的下标是n-1，按照下标来算是$n-1-mid + 1 = n - mid$

#### 【】[单词拆分](https://leetcode.cn/problems/word-break/)

#### 【】[打家劫舍](https://leetcode.cn/problems/house-robber/)

#### 【】[打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

#### 【】[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

- 只能买卖一次,$dp[i][0],dp[i][1]$分表表示，i天持有和i天不持有得到的收益
- i天不持有的状态，可以由i-1天不持有或者i-1天持有得到
  - i-1天不持有，i天也不持有，$dp[i][0] = dp[i-1][0]$，即没有发生买卖和金钱变化
  - i-1天持有，i天不持有,$dp[i][0] = dp[i-1][1] + prices[i]$ ，说明在i天发生了卖出，那么收益需要加上i天出售的价格
- i天持有状态，同样可以由两种状态得到
  - i-1天不持有，i天持有，$dp[i][1] = -prices[i]$，说明i天发生了买入，只能买卖一次，则当前收益直接变为负数
  - i-1天持有，i天持有，$dp[i][1] = dp[i-1][1]$，不发生买卖，不变化

```java
class Solution {
    public int maxProfit(int[] prices) {
        /*
            dp[i][0] i天没有 dp[i][0] = max(dp[i-1][0],prices[i]+dp[i-1][1])
            dp[i][1] i天持有 dp[i][1] = max(dp[i-1][1],-prices[i])
        
        */
        if(prices.length == 1) return 0;
        int[][] dp= new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],prices[i] + dp[i-1][1]);
            dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
        }
        // System.out.print(dp);
        return Math.max(dp[prices.length-1][0],dp[prices.length-1][1]);
    }
}
```

#### 【】[买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

- 可以多次买卖，甚至可以当天买当天卖
- i天不持有的状态，可以由i-1天不持有或者i-1天持有得到
  - i-1天不持有，i天也不持有，$dp[i][0] = dp[i-1][0]$，即没有发生买卖和金钱变化
  - i-1天持有，i天不持有,$dp[i][0] = dp[i-1][1] + prices[i]$ ，说明在i天发生了卖出，那么收益需要加上i天出售的价格
- i天持有状态，同样可以由两种状态得到
  - i-1天不持有，i天持有，$dp[i][1] = dp[i-1][0]-prices[i]$，**不同于[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**，该题可以多次买入，多次卖出，所以要算上之前的收益，即i-1天时不持有的收益
  - i-1天持有，i天持有，$dp[i][1] = dp[i-1][1]$，不发生买卖，不变化

```java
class Solution {
    public int maxProfit(int[] prices) {
        /*
            dp[i][0] i天没有 dp[i][0] = max(dp[i-1][0],prices[i]+dp[i-1][1])
            dp[i][1] i天持有 dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])
        
        */
        if(prices.length == 1) return 0;
        int[][] dp= new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],prices[i] + dp[i-1][1]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        // System.out.print(dp);
        return dp[prices.length-1][0];
        // return Math.max(dp[prices.length-1][0],dp[prices.length-1][1]);
    }
}
```

#### 【】[买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

- 三个状态的处理
  - $dp[i][0]持股，dp[i][1]不持股，当天卖出，dp[i][2]不持股，当天未卖出 $
  - $dp[i][0] = max(dp[i - 1 ][2] - prices[i], dp[i - 1][0] )$，当天持股可以从两种状态转移
    - 前一天不持股，也未卖出，然后在i天买入，$dp[i-1][2] - prices[i]$
    - 前一天持股，什么都不做，i天依旧持股，$dp[i-1][0]$
  - $dp[i][1] = dp[i][0] + prices[i]$
    - 当天不持股，但进行卖出，说明前一天必须持股，由一种状态转移到，$dp[i][0] +  prices[i]$
  - $dp[i][2] = max(dp[i - 1][1],dp[i - 1][2])$，当天不持股，且当天未卖出，由两种状态转移
    - 前一天不持股，但发生了卖出行为，$dp[i-1][1]$
    - 前一天不持股，也没有卖出，$dp[i-1][2]$

```java
class Solution {
    public int maxProfit(int[] prices) {
        /*
            dp[i][0] 持股
            dp[i][1] 不持股，当天卖出
            dp[i][2] 不持股，当天未卖出
            
            dp[i][0] = max(dp[i - 1 ][2] - prices[i], dp[i - 1][0] )
            dp[i][1] = dp[i][0] + prices[i]
            dp[i][2] = max(dp[i - 1][1],dp[i - 1][2])
        */
        if(prices.length == 1) return 0;
        int[][] dp= new int[prices.length][3];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        for(int i = 1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][2]-prices[i],dp[i-1][0]);
            dp[i][1] = dp[i-1][0]+prices[i];
            dp[i][2] = Math.max(dp[i-1][1],dp[i-1][2]);
        }
        return Math.max(dp[prices.length-1][1],dp[prices.length-1][2]);
    }
}
```

- 类似打家劫舍的处理，两个状态
  - $dp[i][0]$第i天不持有，由两种状态得到
    - i-1天不持有，那么保持即可，$dp[i][0] = dp[i-1][0]$
    - i-1天持有，那么要在i天卖出，$dp[i][0] = dp[i-1][1]+prices[i]$
    - 综上：$dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])$

  - $dp[i][1]$第i天持有，由两种状态得到
    - i-1天不持有，那么在i天买入就产生了问题，i-1天发生了卖出行为么，如果发生了卖出行为，那么i-1天就不能买入了，那么产生问题，能否只考虑i-2天不持有的情况，这样纵使i-2天是由于当天的卖出导致的不持有，也不会影响到i天的购买
      - 在i-1天的不持有是当天卖出导致的情况下，不考虑$dp[i-1][0]$显然是合理的
      - 在i-1天不持有，但当天并未发生卖出的情况下$dp[i- 1][0] = dp[i-2][0]$，这种情况下，直接考虑$dp[i-2][0]$显然也是合理的
      - 综上，在i-1天不持有的情况下，直接考虑i-2天是合理的

    - i-1天持有，保持即可$dp[i][1] = dp[i-1][1]$


```java
import static java.lang.Math.max;
class Solution {
    public int maxProfit(int[] prices) {
        /*
            打家劫舍类似处理
            dp[i][0] i天不持有
            dp[i][1] i天持有
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-2][0] - prices[i])
        */
        if(prices.length == 1) return 0;
        int[][] dp= new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = max(prices[1]-prices[0],0);
        dp[1][1] = max(-prices[0],-prices[1]);
        for(int i = 2;i<prices.length;i++){
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1],dp[i-2][0] - prices[i]);
        }
        return dp[prices.length-1][0];
        
    }
}
```

#### **股票小结**

- [原文总结博客](https://leetcode.cn/circle/discuss/qiAgHn/)

- 符号表示

  - 用 n 表示股票价格数组的长度；
  - 用 i 表示第 i 天（i 的取值范围是 0 到 n - 1）；
  - 用 k 表示允许的最大交易次数；
  - 用$T[i][k]$ 表示在第 i 天结束时，最多进行 k 次交易的情况下可以获得的最大收益

- $T[i][k][0]$ 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 0 份股票的情况下可以获得的最大收益；

- $T[i][k][1]$ 表示在第 i 天结束时，最多进行 k 次交易且在进行操作后持有 1 份股票的情况下可以获得的最大收益。

  ```java
  //基准
  T[-1][k][0] = 0, T[-1][k][1] = -Infinity
  T[i][0][0] = 0, T[i][0][1] = -Infinity
  
  //转移方程
  T[i][k][0] = max(T[i - 1][k][0], T[i - 1][k][1] + prices[i])
  T[i][k][1] = max(T[i - 1][k][1], T[i - 1][k - 1][0] - prices[i])
  ```

  - 基准情况中，$T[-1][k][0] = T[i][0][0] = 0$ 的含义和上文相同（没有进行股票交易时没有收益，第一天对应 `i = 0`，因此 `i = -1` 表示没有股票交易），$T[-1][k][1] = T[i][0][1] = -Infinity$ 的含义是在没有进行股票交易时不允许持有股票。
  - 对于状态转移方程中的$ T[i][k][0]$，第 i 天进行的操作只能是休息或卖出，因为在第 i 天结束时持有的股票数量是 0。
    - $T[i - 1][k][0]$ 是休息操作可以得到的最大收益，即保持之前的状态，由不持有到不持有
    - $T[i - 1][k][1] + prices[i]$ 是卖出操作可以得到的最大收益。
    - 注意到允许的最大交易次数是不变的，因为每次交易包含两次成对的操作，买入和卖出。**只有买入操作会改变允许的最大交易次数。**
  - 对于状态转移方程中的 $T[i][k][1]$，第 i 天进行的操作只能是休息或买入，因为在第 i 天结束时持有的股票数量是 1。
    - $T[i - 1][k][1]$ 是休息操作可以得到的最大收益，即保持之前的状态，由持有到持有
    - $T[i - 1][k - 1][0] - prices[i]$ 是买入操作可以得到的最大收益。**注意到允许的最大交易次数减少了一次，因为每次买入操作会使用一次交易。**
  - 为了得到最后一天结束时的最大收益，可以遍历股票价格数组，根据状态转移方程计算$ T[i][k][0]$ 和$ T[i][k][1] $的值。最终答案是 $T[n - 1][k][0]$，**因为结束时持有 0 份股票的收益一定大于持有 1 份股票的收益**。

#### 【】[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

#### 【】[买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

- 包含对k的一个优化策略，明显，最多的交易次数是n/2，即用一半的天数买入，再用一半的天数卖出
- 当`k>n/2`的时候，退化为和k无关，故做简化处理

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int n = prices.length;
        
        if (k >= n / 2) {   
            return maxProfit(prices);
        }

        int[][][] dp = new int[n][k+1][2];
        
        for(int i = 1;i <= k;i++){
            dp[0][i][0] = 0;
            dp[0][i][1] = -prices[0];
        }
        
        for(int i = 1;i<n;i++){
            for(int j = k;j>0;j--){//此处的k可以从k到1，也可以从1到k，理由见下方，
                //从后往前类似背包问题中的处理，为降维做准备
                dp[i][j][0] = Math.max(dp[i-1][j][0],dp[i-1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i-1][j][1],dp[i-1][j-1][0] - prices[i]);
                /**j从k到1
                i第一个循环，可知所有所有需要的数都是已知的
                dp[1][k][0] = max(dp[0][k][0],dp[0][k][1] + prices[1])
                dp[1][k][1] = max(dp[0][k][1],dp[0][k-1][0] - prices[i])
                dp[1][k-1][0] = max(dp[0][k-1][0],dp[0][k-1][1] + prices[1])
                dp[1][k-1][1] = max(dp[0][k-1][1],dp[0][k-2][0] - prices[i])
                dp[1][k-2][0] = max(dp[0][k-2][0],dp[0][k-2][1] + prices[1])
                dp[1][k-2][1] = max(dp[0][k-2][1],dp[0][k-3][0] - prices[i])
				i第二个循环，dp[1][k][0]等在第一个i循环中算出
                dp[2][k][0] = max(dp[1][k][0],dp[1][k][1] + prices[1])
                dp[2][k][1] = max(dp[1][k][1],dp[1][k-1][0] - prices[i])
                  */
            }
        }        
        return dp[n-1][k][0];
    }
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int length = prices.length;
        int[][] dp = new int[length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[length - 1][0];
    }

}

//空间优化
class Solution {
    public int maxProfit(int k, int[] prices) {    
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int n = prices.length;
        
        if (k >= n / 2) {   
            return maxProfit(prices);
        }

        int[][] dp = new int[k+1][2];
        
        for(int i = 1;i <= k;i++){
            dp[i][0] = 0;
            dp[i][1] = -prices[0];
        }
        
        for(int i = 1;i<n;i++){
            for(int j = k;j>0;j--){
                dp[j][0] = Math.max(dp[j][0],dp[j][1] + prices[i]);
                dp[j][1] = Math.max(dp[j][1],dp[j-1][0] - prices[i]);
                
            }
        }
        
        return dp[k][0];
    }
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int profit0 = 0, profit1 = -prices[0];
        int length = prices.length;
        for (int i = 1; i < length; i++) {
            int newProfit0 = Math.max(profit0, profit1 + prices[i]);
            int newProfit1 = Math.max(profit1, profit0 - prices[i]);
            profit0 = newProfit0;
            profit1 = newProfit1;
        }
        return profit0;
    }

}
```

#### 【】[买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

- 更改状态转移方程，选择在卖出**或者**买入的时候收取手续费

#### 【】[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

![image-20231222140412042](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222140412042.png)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {    
        int n = nums.length;
        int res = 0;
        int[] dp= new int[n];
        
        for(int i = 0;i<n;i++){
            for(int j = 0;j<i;j++){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]);
                }
                // if(dp[i] > res ) res = dp[i];
            }
            res = Math.max(res,++dp[i]);
        }
        return res;
    }
}
//下述写法+1的位置不同，在找到dp[j]的时候，已经更新dp[i]为最后的值
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int res = 1;
        int[] dp= new int[n];
		Arrays.fill(dp,1);
        for(int i = 1;i<n;i++){//dp数组用1初始化，这里可以i从1开始
            for(int j = 0;j<i;j++){
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
            if(dp[i] > res ) res = dp[i];
        }
        return res;
    }
}
```

![image-20231222135544905](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222135544905.png)

> 如果可以有LIS允许有重复数，则不需要去重（非严格递增）

- 可用二分解决（时间复杂度相较于$O(n^{2})$,下降为$O(nlogn)$），待解决，[0x3f](https://leetcode.cn/problems/longest-increasing-subsequence/solutions/2147040/jiao-ni-yi-bu-bu-si-kao-dpfu-o1-kong-jia-4zma/)

![image-20231222141609584](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222141609584.png)

![image-20231222142509140](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222142509140.png)

![image-20231222142524234](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222142524234.png)

```java
//0x代码
class Solution {
    public int lengthOfLIS(int[] nums) {
        List<Integer> g = new ArrayList<>();
        for (int x : nums) {
            int j = lowerBound(g, x);
            if (j == g.size()) g.add(x); // >=x 的 g[j] 不存在
            else g.set(j, x);
        }
        return g.size();
    }

    // 开区间写法
    private int lowerBound(List<Integer> g, int target) {
        int left = -1, right = g.size(); // 开区间 (left, right)
        while (left + 1 < right) { // 区间不为空
            // 循环不变量：
            // nums[left] < target
            // nums[right] >= target
            int mid = (left + right) >>> 1;
            if (g.get(mid) < target)
                left = mid; // 范围缩小到 (mid, right)
            else
                right = mid; // 范围缩小到 (left, mid)
        }
        return right; // 或者 left+1
    }
}
```

![image-20231222142837299](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231222142837299.png)

#### 【】[最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

- 与上一题不同的是，序列必须是连续的，所以相应的动态转移方程也发生变化，只需要一层循环

#### 【】[最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

- 子数组需要连续

#### 【】[最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

- 子序列不需要连续，通常这种不需要连续的情况下，$dp[i][j]$表示的不是一定要以i-1，j-1作为结尾，而是表示子序列在$[0:i-1][0:j-1]$这个区间中选择，注意和连续情况的区别。

#### 【】[最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

- 可以采用贪心策略

#### 【】[不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

$dp[i][j]$：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为$dp[i][j]$。

分两种情况考虑：

- $s[i- 1]$与$t[j-1]$相等

  - $dp[i][j] = dp[i-1][j-1] + dp[i-1][j]$
  - $dp[i-1][j-1]$:即不考虑当前s子串和t子串的最后一位
  - $dp[i-1][j]$ :不用$s[i-1]$进行匹配（不能不用$t[j-1]$，因为求的是s子序列中出现t的个数，t中的字母不能少）

  > s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag

- $s[i- 1]$与$t[j-1]$不等

  - 不用s[i - 1]来匹配（就是模拟在s中删除这个元素），即：$dp[i - 1][j]$

**初始化**

- $dp[i][0]$表示什么呢？

  $dp[i][0]$表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

  那么$dp[i][0]$一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

- 再来看$dp[0][j]$

  $dp[0][j]$：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

  那么$dp[0][j]$一定都是0，s如论如何也变成不了t。

- 最后就要看一个特殊位置了，即：$dp[0][0]$ 应该是多少。

  $dp[0][0]$应该是1，空字符串s，可以删除0个元素，变成空字符串t。

#### 【2023-11-14e1p】【flyod】[阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

- [0x3f](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/2525946/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/)
- 最后优化完空间的算法，可以按着以前教科书上flyod算法从小到大选可以经过的中间节点理解

#### 【】[两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

#### 【】[编辑距离](https://leetcode.cn/problems/edit-distance/)

- 对word1删除和对word2进行添加是等价的
- word1 “ad”与word2“a”
- 对word1进行删除，则不考虑d
- 对word2进行添加，同样不考虑d，只考虑前边的部分

#### 【】[回文子串](https://leetcode.cn/problems/palindromic-substrings/)

- 布尔类型的$dp[i][j]$：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是$dp[i][j]$为true，否则为false
- 递推公式
  - 当s[i]与s[j]不相等，$dp[i][j]$一定是false。
  - 当s[i]与s[j]相等时
    - 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
    - 情况二：下标i 与 j相差为1，例如aa，也是回文子串
    - 情况三：下标：i 与  j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看$dp[i + 1][j - 1]$是否为true。

```java
if(s.charAt(i) == s.charAt(j)){
    if(j - i <= 1){
        res ++;
        dp[i][j] = true;
    }else if(dp[i+1][j-1]){
        res++;
        dp[i][j] = true;
    }
}
```

- $dp[i][j]$需要$dp[i+1][j-1]$，所以i从后往前遍历，j从前往后遍历

```java
for(int i = n-1;i >= 0;i--){
    for(int j = i;j<n;j++){
        if(s.charAt(i) == s.charAt(j)){
            if(j - i <= 1){
                res ++;
                dp[i][j] = true;
            }else if(dp[i+1][j-1]){//这里dp[i+1]不会溢出是因为，i=n-1的时候，j只能是n-1，属于j-i<=1的情况
                res++;
                dp[i][j] = true;
            }
        }
    }
}
```

#### 【】[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

![image-20231114202526709](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231114202526709.png)

![image-20231114202535450](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231114202535450.png)

#### 【】[出租车的最大盈利](https://leetcode.cn/problems/maximum-earnings-from-taxi/)

[0x3f](https://leetcode.cn/problems/maximum-earnings-from-taxi/solutions/2558504/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-k15a/)

- 分组思想，将相同的end放到一个集合中

#### 【】[10033. 使 X 和 Y 相等的最少操作次数](https://leetcode.cn/problems/minimum-number-of-operations-to-make-x-and-y-equal/)

- 记忆化搜索
- [0x3f题解](https://leetcode.cn/problems/minimum-number-of-operations-to-make-x-and-y-equal/solutions/2594112/liang-chong-fang-fa-bfsji-yi-hua-sou-suo-djba/)

```java
class Solution {
    private final Map<Integer, Integer> memo = new HashMap<>();

    public int minimumOperationsToMakeEqual(int x, int y) {
        if (x <= y) {
            return y - x;
        }
        if (memo.containsKey(x)) {
            return memo.get(x);
        }
        int ans = x - y;
        ans = Math.min(ans, minimumOperationsToMakeEqual(x / 11, y) + x % 11 + 1);
        ans = Math.min(ans, minimumOperationsToMakeEqual(x / 11 + 1, y) + 11 - x % 11 + 1);
        ans = Math.min(ans, minimumOperationsToMakeEqual(x / 5, y) + x % 5 + 1);
        ans = Math.min(ans, minimumOperationsToMakeEqual(x / 5 + 1, y) + 5 - x % 5 + 1);
        memo.put(x, ans);
        return ans;
    }
}
```

#### 【】[2707. 字符串中的额外字符](https://leetcode.cn/problems/extra-characters-in-a-string/)

- [0x3f题解](https://leetcode.cn/problems/extra-characters-in-a-string/solutions/2286613/dong-tai-gui-hua-cong-ji-yi-hua-sou-suo-wtd7a/)

```java
class Solution {
    public int minExtraChar(String s, String[] dictionary) {
        var set = new HashSet<String>(dictionary.length);
        for (var str : dictionary) set.add(str);
        int n = s.length();
        var f = new int[n + 1];
        for (int i = 0; i < n; i++) {
            f[i + 1] = f[i] + 1; // 不选
            for (int j = 0; j <= i; j++) { // 枚举选哪个
                if (set.contains(s.substring(j, i + 1))) {
                    f[i + 1] = Math.min(f[i + 1], f[j]);
                }
            }
        }
        return f[n];
    }
}

```

#### 【】[1690. 石子游戏 VII](https://leetcode.cn/problems/stone-game-vii/)

- dp数组定义需要一定推导
- [0x](https://leetcode.cn/problems/stone-game-vii/solutions/2629582/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-zktx/)

#### 【】[1997. 访问完所有房间的第一天](https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/)

- [0x](https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solutions/979221/qian-zhui-he-you-hua-dp-by-endlesscheng-j10b/)
- 关注能够进行到下一个房间的必要条件，进而找到对应的周期关系，根据这个关系来写dp方程

#### 【】[845. 数组中的最长山脉](https://leetcode.cn/problems/longest-mountain-in-array/)

山脉数组问题，dp或者双指针，官解双指针还不会

### ==二分==

[0x视频讲解](https://www.bilibili.com/video/BV1AP41137w7/?vd_source=f40328b81769fcf66b90a10650a067f0)

[0x题单](https://leetcode.cn/circle/discuss/SqopEo/)

![image-20240408183654860](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240408183654860.png)

![image-20240408183848156](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240408183848156.png)

![image-20240408192635190](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240408192635190.png)

==循环不变量==：L-1及其左侧一定是比寻找的数小的元素，R+1及其右侧一定是比寻找的数大的元素

$\gt$：如果都是整数的话可以视作寻找第一个$\ge x+1$的，其他的类似

#### `lower_bound`模板

```java
// lowerBound 返回最小的满足 nums[i] >= target 的 i
// 如果数组为空，或者所有数都 < target，则返回 nums.length
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

// 闭区间写法
private int lowerBound(int[] nums, int target) {
    int left = 0, right = nums.length - 1; // 闭区间 [left, right]
    while (left <= right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right+1] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1; // 范围缩小到 [mid+1, right]
        } else {
            right = mid - 1; // 范围缩小到 [left, mid-1]
        }
    }
    return left;
}

// 左闭右开区间写法
private int lowerBound2(int[] nums, int target) {
    int left = 0, right = nums.length; // 左闭右开区间 [left, right)
    while (left < right) { // 区间不为空
        // 循环不变量：
        // nums[left-1] < target
        // nums[right] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1; // 范围缩小到 [mid+1, right)
        } else {
            right = mid; // 范围缩小到 [left, mid)
        }
    }
    return left; // 返回 left 还是 right 都行，因为循环结束后 left == right
}

// 开区间写法
private int lowerBound3(int[] nums, int target) {
    int left = -1, right = nums.length; // 开区间 (left, right)
    while (left + 1 < right) { // 区间不为空
        // 循环不变量：
        // nums[left] < target
        // nums[right] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid; // 范围缩小到 (mid, right)
        } else {
            right = mid; // 范围缩小到 (left, mid)
        }
    }
    return right;
}
```

#### 【10.30e1p】[H 指数 II](https://leetcode.cn/problems/h-index-ii/)

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        # 二分
        n = len(citations)
        
        left,right = 0,n-1
        # []闭区间进行
        while left <= right:
            mid = (left + right) >> 1
            # 上下两种写法等价
            # if citations[mid] >= n-mid:
            #     right = mid - 1
            # else:
            #     left = mid + 1

            if citations[mid] < n - mid:
                left = mid + 1
            else:  
                right = mid - 1
        # left左边都满足：citations[mid] < n - mid
        # right右边都满足：citations[mid] >= n - mid
        return n - left # 最后right在left左边，即right+1 = left，H指数求最大满足的，即right右边个数
```

#### 【2023-11-10e1p】[咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

#### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

头尾被视为$-∞$的情况下，按着递增的方向寻找，一定有峰值

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int n = nums.length;
        int l = 0, r = n-1;
        while(l < r){
            int mid = (r - l) / 2 + l;
            if(nums[mid] < nums[mid+1]){
                l = mid + 1;
            }else{
                r = mid;
            }
        }
        return l;
    }
}
```

#### [1901. 寻找峰值 II](https://leetcode.cn/problems/find-a-peak-element-ii/)

- [0x3f](https://leetcode.cn/problems/find-a-peak-element-ii/solutions/2571587/tu-jie-li-yong-xing-zui-da-zhi-pan-duan-r4e0n/)

```java
class Solution {
    public int[] findPeakGrid(int[][] mat) {
        int left = 0, right = mat.length - 2;
        while (left <= right) {
            int i = (left + right) >>> 1;
            int j = indexOfMax(mat[i]);
            if (mat[i][j] > mat[i + 1][j]) {
                right = i - 1; // 峰顶行号 <= i
            } else {
                left = i + 1; // 峰顶行号 > i
            }
        }
        return new int[]{left, indexOfMax(mat[left])};
    }

    private int indexOfMax(int[] a) {
        int idx = 0;
        for (int i = 0; i < a.length; i++) {
            if (a[i] > a[idx]) {
                idx = i;
            }
        }
        return idx;
    }
}
```

####  [2517. 礼盒的最大甜蜜度](https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/)

比较难，看[0x视频](https://www.bilibili.com/video/BV1FV4y1F7v7/?vd_source=f40328b81769fcf66b90a10650a067f0)吧

核心思想是：==选定一个甜蜜数，明显越小的甜蜜数是越容易满足要求的，大的不容易==

最大值由来：对于一个区间来说，两个数差值的最小值就是将这个区间均分取得的

> 取k个数，即分为k - 1个区间

```java
class Solution {
    public int maximumTastiness(int[] price, int k) {
        Arrays.sort(price);
        int n = price.length;
        int left = 0, right = (price[n - 1] - price[0]) / (k - 1) + 1;
        while(left + 1< right){
            int mid = left + (right - left) / 2;
            if(check(price, mid, k)){
                left = mid;
            }else{
                right = mid;
            }
        }
        return left;
    }
    private boolean check(int[] price, int sweet, int k){
        int x0 = price[0];
        int count = 1;
        for(int n : price){
            if(n >= x0 + sweet){
                count++;
                x0 = n;
            }
        }
        return count >= k;
    }
}
```

:question: 一个疑问

![image-20240424213623063](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240424213623063.png)

![image-20240424213631817](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240424213631817.png)

> 从 > 到 <，一定会经过 =，因为答案一定来源于数组中的元素的差。

#### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

二维的二分，转换为一维

一般地，`a[i] = `$m[\lfloor i/n\rfloor][i\mod n]$

### ==排序==

#### [912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

:star:快速排序

```java
class Solution {
    private static final Random RANDOM = new Random();
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        if(len == 1) return nums;
        quickSort(nums, 0, len - 1);
        return nums;
    }
     private void quickSort(int[] nums, int left, int right) {
        // 小区间使用插入排序
        if(left < right){
            int pIndex = partition(nums, left, right);
            quickSort(nums, left, pIndex - 1);
            quickSort(nums, pIndex + 1, right);
        }
    }

    private int partition(int[] nums, int left, int right) {
        int randomIndex = RANDOM.nextInt(right - left + 1) + left;
        swap(nums, left, randomIndex);

        // 基准值
        int pivot = nums[left];
        int lt = left;
        // 循环不变量：
        // all in [left + 1, lt] < pivot
        // all in [lt + 1, i) >= pivot
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < pivot) {
                lt++;
                swap(nums, i, lt);
            }
        }       
        swap(nums, left, lt);
        return lt;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}

//优化版本，分为三个区间，相等的在中间
class Solution {
    private static final Random RANDOM = new Random();
    public int[] sortArray(int[] nums) {
        int len = nums.length;
        if(len == 1) return nums;
        quickSort(nums, 0, len - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        if(right < left) return;
        int randomIndex = left + RANDOM.nextInt(right - left + 1);
        swap(nums, randomIndex, left);

        // 循环不变量：
        // all in [left + 1, lt] < pivot
        // all in [lt + 1, i) = pivot
        // all in [gt, right] > pivot
        int pivot = nums[left];
        int lt = left;
        int gt = right + 1;

        int i = left + 1;
        while (i < gt) {
            if (nums[i] < pivot) {
                lt++;
                swap(nums, i, lt);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                gt--;
                swap(nums, i, gt);
            }
        }
        swap(nums, left, lt);
        // 注意这里，大大减少了两侧分治的区间
        quickSort(nums, left, lt - 1);
        quickSort(nums, gt, right);
    }


    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }

}
```

### ==拓扑==

#### 【2023-11-1e1p】[参加会议的最多员工数](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/)

- [0x3f](https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solutions/1187830/nei-xiang-ji-huan-shfu-tuo-bu-pai-xu-fen-c1i1b/)
- 未自己写出

### ==位运算==

#### 【2023-11-4e1p】[数组中两个数的最大异或值](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/)

- [0x3f](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/solutions/2511644/tu-jie-jian-ji-gao-xiao-yi-tu-miao-dong-1427d/)
- 判断a，b异或是否等于newAns，可以采用两数之和的方法，这是因为如果 $a \oplus b=newAns$，那么两边同时异或 b，由于$ b\oplus b==0$，所以得到 $a=newAns\oplus b$。这样就可以一边枚举 b，一边在哈希表中查找 $newAns \oplus b $了

#### 【2023-11-6e1p】[最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/)

#### 【23-11-25e1p】[二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/)

-  删除最小元素，`s&(s-1)`

```
s = 101100
s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
s&(s-1) = 101000
```

#### :star:【模板题】[2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)

- [0x](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/solutions/1830911/by-endlesscheng-zai1/)，直接看通用模板部分

```java
class Solution {
    public int[] smallestSubarrays(int[] nums) {
        var n = nums.length;
        var ans = new int[n];
        var ors = new ArrayList<int[]>(); // 按位或的值 + 对应子数组的右端点的最小值
        for (int i = n - 1; i >= 0; --i) {
            ors.add(new int[]{0, i});//按位或的值是从大到小的
            var k = 0;
            for (var or : ors) {
                or[0] |= nums[i];
                if (ors.get(k)[0] == or[0])
                    ors.get(k)[1] = or[1]; // 合并相同值，下标取最小的
                else ors.set(++k, or);
            }
            ors.subList(k + 1, ors.size()).clear();
            // 本题只用到了 ors[0]，如果题目改成任意给定数值，可以在 ors 中查找
            ans[i] = ors.get(0)[1] - i + 1;
        }
        return ans;
    }
}

```

- 可用上述模板：
  - [100271. 或值至少为 K 的最短子数组 II](https://leetcode.cn/problems/shortest-subarray-with-or-at-least-k-ii/)

#### 技巧

```java
//交换两数
a ^= b;
b ^= a;
a ^= b;

//找到二进制中最低位的1
//待补充
```

### ==树状数组==

#### 【2023-11-13e1p】[区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)

- 初识树状数组，[0x3f题解](https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/)

### ==单调栈==

及时去掉无用数据，保持栈中数据有序

#### 【】[每日温度](https://leetcode.cn/problems/daily-temperatures/)

- [0x3f视频](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=f40328b81769fcf66b90a10650a067f0)

- 从左到右：栈中记录==还没算出「下一个更大元素」的那些数（的下标）==。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] res = new int[n];
        stack.push(0);
        for(int i = 1;i<n;i++){
            while(!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]){
                int idx = stack.pop();
                res[idx] = i - idx;
            }            
            stack.push(i);
        }
        return res;
    }
}
```

- 从右到左：

![image-20231115125529939](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231115125529939.png)

单调栈，如果遇到当前元素大于栈顶元素，栈顶元素出栈，循环这个过程直到当前元素小于栈顶元素，当前元素入栈

> 栈中记录==下一个更大元素的「候选项」==

合理性说明：遍历到第一个5的时候，栈中自顶向下为236，由于5的入栈，左边的天数的第一个更高温度已经不可能是2和3的，故将2,3出栈即可

> 相同元素保留最左边的元素

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //从右到左
        int n = temperatures.length;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] res = new int[n];

        for(int i = n-1;i>=0;i--){
            //注意>=，有等于号则在相同元素的出现的同时保存左侧的元素
            while(!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]){
                int idx = stack.pop();
            }
            if(!stack.isEmpty()){//获得结果
                res[i] = stack.peek() - i;
            }
            
            stack.push(i);
        }
        return res;
    }
}
```

#### 【】[下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

#### 【】[下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

#### 【】[接雨水](https://leetcode.cn/problems/trapping-rain-water/)

![image-20231116163050457](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231116163050457.png)

```java
class Solution {
    public int trap(int[] height) {
        Deque<Integer> stack = new ArrayDeque<>();
        int res = 0;
        int n = height.length;
        int pre_idx;
        int pre_num;
        int pre_pre_idx;
        int pre_pre_num;
        for(int i = 0;i<n;i++){
            while(!stack.isEmpty() && height[i] >= height[stack.peek()]){
                //计算积水
                pre_idx = stack.pop();
                pre_num = height[pre_idx];
                if(!stack.isEmpty()){
                    //需要在当前低的地方之前再找一个，但是不需要出栈，后序用得上
                    pre_pre_idx = stack.peek();
                    pre_pre_num = height[pre_pre_idx];
                    res += (i - pre_pre_idx -1) * (Math.min(height[i],pre_pre_num) - pre_num);
                }
            }
            stack.push(i);
        }
        return res;
    }
}
```

![image-20240329153445545](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240329153445545.png)

图示位置，计算完此处的面积之后会在栈中留下两个height值相等的索引，但是不需要刻意处理这种重复。计算面积的h值是 $两侧的小值和中间位置的height相减得到的$，由于栈中元素==非递减==，则有`height[pre] - height[pre_pre]`也就是0。此时进行了一次出栈，栈中就没有重复的元素了。

##### 【接雨水】前后缀分解

![image-20240701195853449](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240701195853449.png)

维护两个数组，一个前缀数组，一个后缀数组，分别表示，从开始到当前为止（包括）的最大值，从当前位置（包括）到最后的最大值

以图中标红的1为例子，找出前缀后缀中较小的高度，这是它所在区间容器的实际壁高，减去自身的高度，就是它所在位置水的单位

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int[] preMax = new int[n]; // preMax[i] 表示从 height[0] 到 height[i] 的最大值
        preMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            preMax[i] = Math.max(preMax[i - 1], height[i]);
        }

        int[] sufMax = new int[n]; // sufMax[i] 表示从 height[i] 到 height[n-1] 的最大值
        sufMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            sufMax[i] = Math.max(sufMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += Math.min(preMax[i], sufMax[i]) - height[i]; // 累加每个水桶能接多少水
        }
        return ans;
    }
}
```

##### 【接雨水】双指针

- 双指针解1

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0;
        int right = height.length - 1;
        int preMax = 0; // 前缀最大值，随着左指针 left 的移动而更新
        int sufMax = 0; // 后缀最大值，随着右指针 right 的移动而更新
        while (left < right) {
            preMax = Math.max(preMax, height[left]);
            sufMax = Math.max(sufMax, height[right]);
            ans += preMax < sufMax ? preMax - height[left++] : sufMax - height[right--];
        }
        return ans;
    }
}
```

- 双指针解2
  - 先找最大的索引，找到之后分为左右两部分计算
  - 对于左侧的，维护指针`left,cur`，如果`h[cur] >= h[left]`，说明有凹陷产生，进行一次计算，直接算`h[left] * (cur - left - 1)`，同时更新`left = cur`，但这样算出来是多算的
  - `h[cur] < h[left]`的时候，需要将之前多算的部分减去，直接在结果上减去`h[cur]`即可
  - 对于右侧，同理，但从后往前

```java
//双指针解
import java.time.LocalTime;
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int max_id = 0;
        for(int i = 0;i<n;i++){
            max_id = height[i] >= height[max_id] ? i:max_id; 
        }
        int left = 0, right = max_id, cur = 0;
        int res = 0;
        while(cur <=right){
            if(cur > left){
                if(height[cur] >= height[left]){
                    //+
                    res += height[left] * (cur - left -1);
                    left = cur;
                }else{
                    //-
                    if(cur != left) res -= height[cur];
                }
            }            
            cur ++;
        }
        left = max_id ; right = n -1; cur = n -1;
        while(cur >= left){
            if(cur < right){
                if(height[cur] >= height[right]){
                   res += height[right] * (right - cur - 1);
                    right = cur;
                }else{
                    if(cur != right) res -= height[cur];
                }
            }        
            cur --;
        }
        return res;
    }
}
```

#### 【】[柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

[宫水三叶题解](https://leetcode.cn/problems/largest-rectangle-in-histogram/solutions/1856193/by-ac_oier-i470/)

为了方便，我们令 heights 为 hs。

最终矩形的高度必然取自某个 $hs[i]$，因此我们可以枚举最终矩形的高度来做。

问题转换为当使用某个 $hs[i]$作为矩形高度时，该矩形所能取得的最大宽度为多少。

假设我们能够预处理出 l 和 r 数组，其中 $l[i]$代表位置 i 左边最近一个比其小的位置（初始值−1），$r[i]$代表位置 i 右边最近一个比其小的位置（初始值为 n），那么 $r[i] - l[i] - 1$ 则是以 $hs[i]$ 作为矩形高度时所能取得的最大宽度。

预处理 l 和 r 则是经典的「求最近一个比当前值大的位置」单调栈问题，可参考每日温度中正序和逆序处理的两种方法。

#### 【23-11-17e1p】[最大和查询](https://leetcode.cn/problems/maximum-sum-queries/)

- 抄的[0x3f](https://leetcode.cn/problems/maximum-sum-queries/solutions/2305395/pai-xu-dan-diao-zhan-shang-er-fen-by-end-of9h/)

#### 【23-11-27e1p】[子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

- [0x3f](https://leetcode.cn/problems/sum-of-subarray-minimums/solutions/1930857/gong-xian-fa-dan-diao-zhan-san-chong-shi-gxa5/)

#### [2866. 美丽塔 II](https://leetcode.cn/problems/beautiful-towers-ii/)

- [0x3f](https://leetcode.cn/problems/beautiful-towers-ii/solutions/2456562/qian-hou-zhui-fen-jie-dan-diao-zhan-pyth-1exe/)
- 美丽塔1的数据量小，可以直接暴力
- 撤销操作（官解中有类似操作，更容易理解一点）
- 维护的单调栈从栈底到栈顶严格递增

```java
class Solution {
    public long maximumSumOfHeights(List<Integer> maxHeights) {
        int[] a = maxHeights.stream().mapToInt(i -> i).toArray();
        int n = a.length;
        long[] suf = new long[n + 1];
        var st = new ArrayDeque<Integer>();
        st.push(n); // 哨兵
        long sum = 0;
        for (int i = n - 1; i >= 0; i--) {
            int x = a[i];
            while (st.size() > 1 && x <= a[st.peek()]) {
                int j = st.pop();
                sum -= (long) a[j] * (st.peek() - j); // 撤销之前加到 sum 中的,相同的元素只保留最左边的，通过下标差来判断该元素有多少个(st.peek() - j)
            }
            sum += (long) x * (st.peek() - i); // 从 i 到 st.peek()-1 都是 x
            suf[i] = sum;
            st.push(i);
        }
        long ans = sum;
        st.clear();
        st.push(-1); // 哨兵
        long pre = 0;
        for (int i = 0; i < n; i++) {
            int x = a[i];
            while (st.size() > 1 && x <= a[st.peek()]) {
                int j = st.pop();
                pre -= (long) a[j] * (j - st.peek()); // 撤销之前加到 pre 中的
            }
            pre += (long) x * (i - st.peek()); // 从 st.peek()+1 到 i 都是 x
            ans = Math.max(ans, pre + suf[i + 1]);
            st.push(i);
        }
        return ans;
    }
}
```

#### [1944. 队列中可以看到的人数](https://leetcode.cn/problems/number-of-visible-people-in-a-queue/)

从右往左开始遍历，同时维护一个单调栈，栈中元素从大大小排列

如果当前元素大于栈顶元素，那么能看到的数目temp就加一，最后统计该位置能看到的人数时候

- 如果栈中还有元素，那么最终的结果是temp+1，因为此时栈顶的大于当前位置的元素，也是能看到的
- 如果栈中没有元素，那么最终的结果就是temp

> 单调栈的原则就是及时去掉无用的数据，保持栈中数据的有效
>
> 对于这题而言，当有更大的元素出现的时，较小的元素已经不能被接下来的数看到了，所以可以去掉

```java
class Solution {
    public int[] canSeePersonsCount(int[] heights) {
        //单调栈
        int n = heights.length;
        int[] res = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();
        //从右到左
        stack.push(n-1);
        for(int i = n-2;i>=0;i--){
            int temp = 0;
            while(!stack.isEmpty() && heights[i] > heights[stack.peek()]){
                temp++;
                stack.pop();
            }
            if(!stack.isEmpty()) res[i] = temp +1;
            else res[i] = temp;
            stack.push(i);
        }
        res[n-1] = 0;
        return res;
    }
}
```

### ==单调队列==

#### [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206224825731.png" alt="image-20231206224825731" style="zoom:50%;" />

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206224723441.png" alt="image-20231206224723441" style="zoom:50%;" />

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231206225311661.png" alt="image-20231206225311661" style="zoom:50%;" />

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n - k + 1];
        int idx = 0;
        for(int i = 0;i < n;i++){
            while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){
                deque.pollLast();
            }
            if(!deque.isEmpty() && i - deque.peekFirst() + 1 >k){
                deque.pollFirst();
            }
            deque.offerLast(i);
            
            if(i >= k-1){
                res[idx++] = nums[deque.peekFirst()];
            }
            
        }
        return res;
    }
}
```

#### [1696. 跳跃游戏 VI](https://leetcode.cn/problems/jump-game-vi/)

[0x](https://leetcode.cn/problems/jump-game-vi/solutions/2631981/yi-bu-bu-you-hua-cong-di-gui-dao-di-tui-84qn3/)

- 使用单调队列优化动态规划

### ==**树**==

#### 三种遍历的迭代写法

##### 中序

- 每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。
- 在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。

```java
/*
栈S;
p= root;
while(p || S不空){
    while(p){
        p入S;
        p = p的左子树;
    }
    p = S.top 出栈;
    访问p;
    p = p的右子树;
}
*/
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        TreeNode now = root;
        Deque<TreeNode> stack = new ArrayDeque<>();
        List<Integer> res = new ArrayList<>();
        while(now != null || !stack.isEmpty()){
            while(now != null){
                stack.push(now);
                now = now.left;
            }
            if(!stack.isEmpty()){
                now = stack.pop();//Deque的pop()遇到空值，会出现异常，采用offerFirst()模拟栈，则为空返回特殊值
                res.add(now.val);
                now = now.right;
            }
        }
        return res;
    }
}
```

##### 先序

- 每到一个节点 A，就应该立即访问它。
- 因为，每棵子树都先访问其根节点。对节点的左右子树来说，也一定是先访问根。
- 在 A 的两棵子树中，遍历完左子树后，再遍历右子树。
- 因此，在访问完根节点后，遍历左子树前，要将右子树压入栈。

```java
/*
栈S;
p= root;

while(p || S不空){
    while(p){
        访问p节点；
        p的右子树入S;
        p = p的左子树;
    }
    p = S栈顶弹出;
}
*/
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode now = root;
        while(now != null || !stack.isEmpty()){
            while(now != null){
                if(now.right != null) stack.push(now.right);
                res.add(now.val);
                now = now.left;
            }
            if(!stack.isEmpty()){
                now = stack.pop();
            }
        }
        return res;
    }
}
```

##### 后序

- 第一种，利用前序遍历相似处理，但是是*根右左*的顺序
- 输出的时候反转，就变成了左右根

```java
/**
栈S;
p= root;

while(p || S不空){
    while(p){
        访问p节点；
        p的左子树入S;
        p = p的右子树;
    }
    p = S栈顶弹出;
}
结果序列逆序;
*/
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode now = root;
        while(now != null || !stack.isEmpty()){
            while(now != null){
                if(now.left != null) stack.push(now.left);
                res.add(now.val);
                now = now.right;
            }
            if(!stack.isEmpty()){
                now = stack.pop();
            }
        }
        Collections.reverse(res);
        return res;
    }
}
```

- 第二种，每到一个节点 `A`，因为根要最后访问，将其入栈。然后遍历左子树，遍历右子树，最后返回到 `A`。

- 但是出现一个问题，无法区分是从左子树返回，还是从右子树返回。

- 利用标记辨别，初始为False，表明从左边返回，为True时候表示从右边返回

  > 或者用prev来记录返回的位置

```java
/**
栈S;
p= root;
T<节点,True/False> : 节点标记; //初始为False

while(p || S不空){
    while(p){
        p入S;
        p = p的左子树;
    }
    while(S不空 且 T[S.top] = True){
        访问S.top;
        S.top出S;
    }
    if(S不空){
        p = S.top 的右子树;
        T[S.top] = True;
    }
}
*/
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        Map<TreeNode,Boolean> flag = new HashMap<>();
        List<Integer> res = new ArrayList<>();
        TreeNode now = root;
        while(now != null || !stack.isEmpty()){
            while(now != null){
                stack.push(now);
                now = now.left;
            }
            while(!stack.isEmpty() && flag.getOrDefault(stack.peek(),false)){
                res.add(stack.pop().val);
            }
            if(!stack.isEmpty()){
                flag.put(stack.peek(),true);                
                now = stack.peek().right;    
            }
        }
        return res;
    }
}
//使用prev指针的写法
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```

#### 层序遍历

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {        
        Deque<TreeNode> que = new ArrayDeque<>();
        TreeNode now = root;
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;
        que.offerLast(root);
        while(!que.isEmpty()){
            int n = que.size();
            List<Integer> temp = new ArrayList<>();
            while(n-- > 0){
                TreeNode vis = que.pollFirst();
                temp.add(vis.val);
                if(vis.left != null) que.offerLast(vis.left);
                if(vis.right != null) que.offerLast(vis.right);
            }
            res.add(temp);
        }
        return res;
    }
}
```

#### 判断是否对称

```java
//递归
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return judge(root,root);
    }
    public boolean judge(TreeNode node1,TreeNode node2){
        if(node1 == null && node2 == null){
            return true;
        }
        if(node1 == null || node2 == null){
            return false;
        }
        return node1.val == node2.val && judge(node1.left,node2.right) && judge(node1.right,node2.left);
    }

}
//迭代
public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);
        deque.offerLast(root.right);
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);
            deque.offerFirst(leftNode.right);
            deque.offerLast(rightNode.right);
            deque.offerLast(rightNode.left);
        }
        return true;
    }

//使用ArrayDeque的迭代，以为ArrayDeque中不能插入null，所以修改了处理顺序，队列中的数据都是合法的，判断取出节点之后的节点
public boolean isSymmetric(TreeNode root) {
        Deque<TreeNode> queue = new ArrayDeque<>();
        if(judge10(root.left,root.right)){
            if(root.left != null){
                queue.offerLast(root.left);
                queue.offerLast(root.right);
            }
        }else{
            return false;
        }
        
        while(!queue.isEmpty()){
            TreeNode left_n = queue.pollFirst();
            TreeNode right_n = queue.pollFirst();
            if(judge10(left_n.left,right_n.right)){
                if(left_n.left != null){
                    queue.offerLast(left_n.left);
                    queue.offerLast(right_n.right);
                }
            }else{
                return false;
            }
            if(judge10(left_n.right,right_n.left)){
                if(left_n.right != null){
                    queue.offerLast(left_n.right);
                    queue.offerLast(right_n.left);
                }
            }else{
                return false;
            }
        }
        return true;
    }
    public boolean judge10(TreeNode node1,TreeNode node2){
        if(node1 == null && node2 == null) return true;
        if(node1 == null || node2 == null || node1.val != node2.val) return false;
        return true;
    }
```

#### [LCR 144. 翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)

```java
//递归
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null) return root;
        sub(root);
        return root;
    }
    private void sub(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
        if(node.left != null) sub(node.left);
        if(node.right != null) sub(node.right);
    }
}
//迭代
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root == null || (root.left == null && root.right == null)) return root;
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while(!deque.isEmpty()){
            TreeNode cur = deque.poll();
            TreeNode temp = cur.left;
            cur.left = cur.right;
            cur.right = temp;
            if(cur.left != null) deque.offer(cur.left);
            if(cur.right != null) deque.offer(cur.right);
        }
        return root; 
    }  
}
```

#### 高度和深度

- 深度从上到下维护，高度从下到上

- 待补充（代码随想录平衡二叉树部分）

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

树形dp

```java
class Solution {
    private int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        dfs(root);
        return ans;
    }
    public int dfs(TreeNode node){
        if(node == null){
            return -1;
        }
        int l = dfs(node.left) + 1;
        int r = dfs(node.right) + 1;
        ans = Math.max(ans, l + r);
        return Math.max(l, r);
    }
}
```

#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

[0x](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/2227021/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-n9s91/?envType=study-plan-v2&envId=top-100-liked)

```java
class Solution {
    private int ans = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }

    private int dfs(TreeNode node) {
        if (node == null) {
            return 0; // 没有节点，和为 0
        }
        int lVal = dfs(node.left); // 左子树最大链和
        int rVal = dfs(node.right); // 右子树最大链和
        ans = Math.max(ans, lVal + rVal + node.val); // 两条链拼成路径
        return Math.max(Math.max(lVal, rVal) + node.val, 0); // 当前子树最大链和
    }
}
```

#### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

[0x](https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/?envType=study-plan-v2&envId=top-100-liked)

按照前缀和思路，已知现在前缀和s，找`s-target`的数量

树的前缀和是从根节点到当前节点的值，注意添加0值

```java
class Solution {
    private int ans;
    public int pathSum(TreeNode root, int targetSum) {
        Map<Long, Integer> cnt = new HashMap<>();
        cnt.put(0L, 1);
        preOrder(root, cnt, targetSum, 0);
        return ans;
    }
    private void preOrder(TreeNode node, Map<Long, Integer> map, int targetSum, long s){
        if(node == null) return;
        s += node.val;
        ans += map.getOrDefault(s - targetSum, 0);
        map.put(s , map.getOrDefault(s, 0) + 1);
        preOrder(node.left, map, targetSum, s);
        preOrder(node.right, map, targetSum, s);
        map.put(s , map.getOrDefault(s, 0) - 1);
    }
}
```

####  [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    int[] preorder;
    int[] inorder;
    Map<Integer,Integer> map_in;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        map_in = new HashMap<>();
        int n = inorder.length;
        for(int i = 0;i < n;i++){
            map_in.put(inorder[i],i);
        }
        return subBuild(0,n-1,0,n-1);
    }
    public TreeNode subBuild(int pre_left,int pre_right, int in_left, int in_right){
        if(pre_left > pre_right || in_left > in_right){
            return null;
        }
        int pre_root = pre_left;
        int in_root = map_in.get(preorder[pre_root]);
        TreeNode node = new TreeNode(preorder[pre_root]);

        int left_size = in_root - in_left;
        node.left = subBuild(pre_left+1, pre_left + left_size,in_left,in_root-1);
        node.right = subBuild(pre_left + left_size + 1,pre_right,in_root+1,in_right);

        return node;
    }
}
```

#### [从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    int[] inorder;
    int[] postorder;
    Map<Integer,Integer> map_in;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        this.inorder = inorder;
        this.postorder = postorder;
        map_in = new HashMap<>();
        int n = inorder.length;
        for(int i = 0;i<n;i++){
            map_in.put(inorder[i],i);
        }
        return subBuild(0,n-1,0,n-1);
    }
    public TreeNode subBuild(int post_left,int post_right,int in_left,int in_right){
        if (post_left > post_right || in_left > in_right){
            return null;
        }
        int post_root = post_right;
        int in_root = map_in.get(postorder[post_root]);
        TreeNode node = new TreeNode(postorder[post_root]);

        int left_size = in_root - in_left;

        node.left = subBuild(post_left,post_left + left_size - 1,in_left,in_root-1);
        node.right = subBuild(post_left + left_size,post_right-1,in_root+1,in_right);
        return node;
    }   
}
```

#### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

 O(1)空间解法

先序遍历是【根左右】，直观的做法是遍历到当前节点，将下一个节点左节点移动到右节点，但是这样会产生问题：右节点还没有访问，就已经被更新了

采用后序遍历，但是【右左根】的顺序，访问到当前节点的时候，上一个节点正好是左节点，即先序遍历的下一个节点，同时右子树已经访问过了，可以放心将当前节点的右指针，修改为【上一个节点】，即【左节点】

```java
class Solution {
    private TreeNode prev = null;
    public void flatten(TreeNode root) {
        if(root != null){
            flatten(root.right);
            flatten(root.left);
            root.right = prev;
            root.left = null;
            prev = root;
        }     
    }
}
```

#### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

:clock1:[0x题解](https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/?envType=study-plan-v2&envId=top-100-liked)中还有先序和后续的做法

```java
class Solution {
    Long prev = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        if(!isValidBST(root.left) || prev >= root.val) return false;
        
        prev = (long)root.val;
        return isValidBST(root.right);
               
    }
}
```

#### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

中序方法

注意k要是全局的，传参进去比较麻烦

```java
class Solution {
    private int ans;
    private int _k;
    public int kthSmallest(TreeNode root, int k) {
        _k = k;
        sub(root);
        return ans;
    }
    private void sub(TreeNode node){
        if(node != null){
            sub(node.left);
            if(--_k == 0) ans = node.val;
            sub(node.right);
        }
    }
}
```

#### [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

最开始写法根据postorder中的倒数第二个作为根，但是一直不过，为什么？

```java
class Solution {
    int[] preorder;
    int[] postorder;
    HashMap<Integer,Integer> map;
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        this.preorder = preorder;
        this.postorder = postorder;
        int n = preorder.length;
        this.map = new HashMap<>();
        for(int i = 0;i<n;i++){
            map.put(postorder[i],i);
        }
        return subTree(0,n-1,0,n-1);
    }
    public TreeNode subTree(int preleft,int preright,int postleft, int postright){
        if(preleft > preright || postleft >postright) return null;
        if(preleft == preright){
            return new TreeNode(preorder[preleft]);
        }
        TreeNode cre = new TreeNode(preorder[preleft]);
        int next_root = preorder[preleft + 1];
        int left_size = map.get(next_root) - postleft + 1;

        cre.left = subTree(preleft + 1, preleft + left_size, postleft, postleft + left_size - 1);
        cre.right = subTree(preleft + left_size + 1,preright,postleft + left_size,postright - 1);

        return cre;
    }
}

```

#### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

难点为如何不用额外空间（递归栈不算），以及如何对众数进行统计

直观来看，在一个递增的数组上统计众数是简单的，幸运的是，很容易将二叉搜索树中的数与递增数组对应

在数组上统计，我们只需要比较当前数与相邻数是否相等，就可以判断出来一个数的频率，我们可以第一次遍历先获得最大频率，第二次遍历再将这些拥有最大频率的数存入答案中

那么，如何减少遍历的次数？

这里采用回溯的思想，我们维护一个maxCount和每个数的count

- 当前数的count>maxCount，则答案中已有的数都不合法，舍弃，修改maxCount为当前数的count并把当前数加入答案
- 当前数的count=maxCount，则向答案中加入当前数
- 当前数的count<maxCount，则当前数没可能是众数，不执行任何操作

```java
class Solution {
    List<Integer> res;
    int count = 0;
    int maxCount = 0;
    TreeNode pre = null;
    public int[] findMode(TreeNode root) {
        res = new ArrayList<>();
        inorder(root);
        return res.stream().mapToInt(i->(int)i).toArray();
    }
    public void inorder(TreeNode node){
        if(node != null){
            inorder(node.left);
            if(pre == null) count = 1;
            else if(pre.val == node.val) count++;
            else count = 1;
            
            pre = node;
            if(count == maxCount) res.add(node.val);
            else if(count > maxCount){
                maxCount = count;
                res.clear();
                res.add(node.val);
            }

            inorder(node.right);
        }
    }
}
```

#### :star: [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

递归

[题解](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/2023872/fen-lei-tao-lun-luan-ru-ma-yi-ge-shi-pin-2r95/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == p || root == q || root == null) return root;
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left != null && right != null) return root;
        else if(left != null && right == null) return left;
        else return right;
    }
}
```

![image-20231225125256395](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231225125256395.png)

记录父节点

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        Map<TreeNode, TreeNode> parent = new HashMap<>();

        dfs(root, null, parent);

        Set<TreeNode> resSet = new HashSet<>();
        while (p != null) {
            resSet.add(p);
            p = parent.get(p);
        }

        while (q != null) {
            if (resSet.contains(q)) {
                return q;
            }
            q = parent.get(q);
        }
        return null;
    }
    private void dfs(TreeNode node, TreeNode parentNode, Map<TreeNode, TreeNode> parent) {
        if (node == null) {
            return;
        }
        parent.put(node, parentNode);
        dfs(node.left, node, parent);
        dfs(node.right, node, parent);
    }
}
```

![image-20231225125306096](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231225125306096.png)

#### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

利用二叉搜索树的性质，如果p和q的值出现在root的一左一右，则root就是最近公共祖先，因为root左子树上边的值都是比root的值小的， root右子树的值都是比root大的，再往下遍历，一定没有公共祖先

```java
//递归
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val < root.val && q.val < root.val) return lowestCommonAncestor(root.left,p,q);
        else if(p.val > root.val && q.val > root.val) return lowestCommonAncestor(root.right,p,q);
        else return root;        
    }
}
//迭代
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null){
            if(p.val < root.val && q.val < root.val) root = root.left;
            else if(p.val > root.val && q.val > root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```

#### :star:[450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

删除的几种情况:

- :one: 没找到删除的节点，遍历到空节点，直接返回了
- 找到删除的节点
  - :two: 左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  - :three: 删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - :four: 删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - :five: 左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子（删除节点右子树的最小值节点）上，返回删除节点右孩子为新的根节点。

```java
//递归
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return root;
        if (root.val == key) {
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            } else {
                TreeNode cur = root.right;
                while (cur.left != null) {
                    cur = cur.left;
                }
                cur.left = root.left;
                root = root.right;
                return root;
            }
        }
        if (root.val > key) root.left = deleteNode(root.left, key);
        if (root.val < key) root.right = deleteNode(root.right, key);
        return root;
    }
}
```

> 有返回值的递归方法，`root.left=deleteNode(root.left, key)`已经包含了上一个节点的处理
>
> 没有返回的递归方法，则要自己记录上一个节点的位置

迭代的方法需要维护上一个遍历的节点

```java
class Solution {
  public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null){
      return null;
    }
    //寻找对应的对应的前面的节点，以及他的前一个节点
    TreeNode cur = root;
    TreeNode pre = null;
    while (cur != null){
      if (cur.val < key){
        pre = cur;
        cur = cur.right;
      } else if (cur.val > key) {
        pre = cur;
        cur = cur.left;
      }else {
        break;
      }
    }
    if (pre == null){
      return deleteOneNode(cur);
    }
    if (pre.left !=null && pre.left.val == key){
      pre.left = deleteOneNode(cur);
    }
    if (pre.right !=null && pre.right.val == key){
      pre.right = deleteOneNode(cur);
    }
    return root;
  }

  public TreeNode deleteOneNode(TreeNode node){
    if (node == null){
      return null;
    }
    if (node.right == null){
      return node.left;
    }
    TreeNode cur = node.right;
    while (cur.left !=null){
      cur = cur.left;
    }
    cur.left = node.left;
    return node.right;
  }
}
```

#### :star: [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

当前节点值比low小，左子树中的节点也比low小，搜寻右子树，保留在区间中的节点

当前节点值比high大，同理

如果当前节点值在区间中，则分别递归向左右子树寻找

```java
//递归
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null) return root;
        if(root.val < low) return trimBST(root.right,low,high);
        if(root.val > high) return trimBST(root.left,low,high);
        root.left =  trimBST(root.left,low,high);
        root.right = trimBST(root.right,low,high);
        return root;
    }
}
```

迭代，在剪枝的时候，可以分为三步：

- 将root移动到[L, R] 范围内，注意是左闭右闭区间
- 剪枝左子树
- 剪枝右子树

```java
//迭代
class Solution {
    //iteration
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root == null)
            return null;
        while(root != null && (root.val < low || root.val > high)){
            if(root.val < low)
                root = root.right;
            else
                root = root.left;
        }

        TreeNode curr = root;
        
        //deal with root's left sub-tree, and deal with the value smaller than low.
        while(curr != null){
            while(curr.left != null && curr.left.val < low){
                curr.left = curr.left.right;
            }
            curr = curr.left;
        }
        //go back to root;
        curr = root;

        //deal with root's righg sub-tree, and deal with the value bigger than high.
        while(curr != null){
            while(curr.right != null && curr.right.val > high){
                curr.right = curr.right.left;
            }
            curr = curr.right;
        }
        return root;
    }
}
```

#### [1325. 删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/)

经典后序遍历的一种写法

```java
class Solution {
    public TreeNode removeLeafNodes(TreeNode root, int target) {
        if(root == null){
            return null;
        }
        root.left = removeLeafNodes(root.left,target);
        root.right = removeLeafNodes(root.right,target);
        if(root.left == null && root.right == null && root.val == target){
            return null;
        }
        return root;
    }
}
```

####  :question:[2385. 感染二叉树需要的总时间](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/)

- 一个从当前节点向树的两边遍历的例子
- [0x3f](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/2753470/cong-liang-ci-bian-li-dao-yi-ci-bian-li-tmt0x/)

```java
class Solution {
    private TreeNode startNode;
    private final Map<TreeNode, TreeNode> fa = new HashMap<>();

    public int amountOfTime(TreeNode root, int start) {
        dfs(root, null, start);
        return maxDepth(startNode, startNode);
    }

    private void dfs(TreeNode node, TreeNode from, int start) {
        if (node == null) {
            return;
        }
        fa.put(node, from); // 记录每个节点的父节点
        if (node.val == start) {
            startNode = node; // 找到 start
        }
        dfs(node.left, node, start);
        dfs(node.right, node, start);
    }

    private int maxDepth(TreeNode node, TreeNode from) {
        if (node == null) {
            return -1; // 注意这里是 -1，因为 start 的深度为 0
        }
        int res = -1;
        if (node.left != from) {
            res = Math.max(res, maxDepth(node.left, node));
        }
        if (node.right != from) {
            res = Math.max(res, maxDepth(node.right, node));
        }
        if (fa.get(node) != from) {
            res = Math.max(res, maxDepth(fa.get(node), node));
        }
        return res + 1;
    }
}

```

#### 层序生成二叉树

```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int val) {
        this.val = val;
    }

    public static TreeNode create(List<Integer> nodeList) {
        if (nodeList == null || nodeList.isEmpty()) {
            return null;
        }

        TreeNode root = new TreeNode(nodeList.get(0));
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);

        int i = 1;
        while (!queue.isEmpty() && i < nodeList.size()) {
            TreeNode current = queue.poll();
            if (i < nodeList.size() && nodeList.get(i) != null) {
                current.left = new TreeNode(nodeList.get(i));
                queue.offer(current.left);
            }
            i++;
            if (i < nodeList.size() && nodeList.get(i) != null) {
                current.right = new TreeNode(nodeList.get(i));
                queue.offer(current.right);
            }
            i++;
        }
        return root;
    }
}
```

### ==图==

#### DFS

```java
待补充
//4方向图的遍历
```

##### 【2023-10-31e1p】[每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/)

- [0x3f题解](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/solutions/2505883/tu-jie-yi-zhang-tu-miao-dong-duo-chong-x-q095/)

##### [2192. 有向无环图中一个节点的所有祖先](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/)

典型的dfs应用，一个小tip

![image-20240404090549611](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240404090549611.png)

  [0x3f](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/2723203/liang-chong-fang-fa-ni-xiang-zheng-xiang-rwjs/)

```java
class Solution {
    public List<List<Integer>> getAncestors(int n, int[][] edges) {
        List<Integer>[] g = new ArrayList[n];
        Arrays.setAll(g, i -> new ArrayList<>());
        for (int[] e : edges) {
            g[e[0]].add(e[1]);
        }

        List<Integer>[] ans = new ArrayList[n];
        Arrays.setAll(ans, i -> new ArrayList<>());
        int[] vis = new int[n];
        Arrays.fill(vis, -1);
        for (int start = 0; start < n; start++) {
            dfs(start, start, g, vis, ans); // 从 start 开始 DFS
        }
        return Arrays.asList(ans);
    }

    private void dfs(int x, int start, List<Integer>[] g, int[] vis, List<Integer>[] ans) {
        vis[x] = start; // 避免重复访问
        for (int y : g[x]) {
            if (vis[y] != start) {
                ans[y].add(start); // start 是访问到的点的祖先
                dfs(y, start, g, vis, ans); // 只递归没有访问过的点
            }
        }
    }
}

```

#### BFS

```java
待补充
```

为了防止重复，进队列的点即刻视为已经遍历过的点。

![image-20231121180801073](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231121180801073.png)

> 图有问题，最右边的一张中红色的和它右边的绿色1应该换位

####  Dijkstra

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

[0x](https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/)

```java
//朴素dijstra，适用于稠密图
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        final int INF = Integer.MAX_VALUE / 2; // 防止加法溢出
        int[][] g = new int[n][n]; // 邻接矩阵
        for (int[] row : g) {
            Arrays.fill(row, INF);
        }
        for (int[] t : times) {
            g[t[0] - 1][t[1] - 1] = t[2];
        }

        int maxDis = 0;
        int[] dis = new int[n];
        Arrays.fill(dis, INF);
        dis[k - 1] = 0;
        boolean[] done = new boolean[n];
        while (true) {
            int x = -1;
            for (int i = 0; i < n; i++) {
                if (!done[i] && (x < 0 || dis[i] < dis[x])) {
                    x = i;
                }
            }
            if (x < 0) {
                return maxDis; // 最后一次算出的最短路就是最大的
            }
            if (dis[x] == INF) { // 有节点无法到达
                return -1;
            }
            maxDis = dis[x]; // 求出的最短路会越来越大
            done[x] = true; // 最短路长度已确定（无法变得更小）
            for (int y = 0; y < n; y++) {
                // 更新 x 的邻居的最短路
                dis[y] = Math.min(dis[y], dis[x] + g[x][y]);
            }
        }
    }
}
```

```java
//堆优化，适合于稀疏矩阵
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        List<int[]>[] g = new ArrayList[n];
        Arrays.setAll(g, i->new ArrayList<>());
        for(int[] t : times){
            g[t[0] - 1].add(new int[]{t[1] - 1, t[2]});
        }
        int maxDis = 0;
        int left = n;
        int[] dis = new int[n];
        Arrays.fill(dis, Integer.MAX_VALUE);
        dis[k - 1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.offer(new int[]{0, k - 1});
        while(!pq.isEmpty()){
            int[] p = pq.poll();
            int dx = p[0];
            int x = p[1];
            if(dx > dis[x]){
                continue;
            }
            maxDis = dx;
            left--;
            for(int[] e : g[x]){
                int y = e[0];
                int newDis = dx + e[1];
                if(newDis < dis[y]){
                    dis[y] = newDis;
                    pq.offer(new int[]{newDis, y});
                }
            }
        }
        return left == 0 ? maxDis : -1;
    }
}
```

#### prim算法

[1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        return prim(points, 0);
    }
    public int prim(int[][] points, int start){
        int n = points.length;
        int[][] g = new int[n][n];
        //1. 临接矩阵
        for(int i = 0;i < n;i++){
            for(int j = i+1;j < n;j++){
                int dis = Math.abs(points[i][0] - points[j][0]) 
                        + Math.abs(points[i][1] - points[j][1]);
                g[i][j] = g[j][i] = dis;
            }
        }
        //记录V中的点到Vnew的最近距离
        int[] lowcost = new int[n];
        Arrays.fill(lowcost, Integer.MAX_VALUE);
        //记录V中的点是否加入到Vnew
        boolean[] v = new boolean[n];

        //2. 将start加入Vnew
        v[start] = true;
        for(int i = 0;i<n;i++){
            if(i == start) continue;
            lowcost[i] = g[i][start];
        }
        int res = 0;
        //3. 遍历剩下若干未加入到Vnew的节点
        for(int i = 1;i<n;i++){
            //找出此时v中，离Vnew最近的点
            int minIdx = -1;
            int minVal = Integer.MAX_VALUE;
            for(int j = 0;j < n; j++){
                if(v[j] == false && lowcost[j] < minVal){
                    minIdx = j;
                    minVal = lowcost[j];
                }
            }
            // 将最近的点计入Vnew
            v[minIdx] = true;
            res += minVal;
            //4. 更新集合V中剩余所有点的lowcost
            for(int j = 0; j < n; j++){
                if(v[j] == false && g[j][minIdx] < lowcost[j]){
                    lowcost[j] = g[j][minIdx];
                }
            }
        }
        return res;
    }
}
```

#### 【】[所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

#### 【】[太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

从边缘出发，统计能够流向当前海域的格子集合，两片海域求得的集合交集即是答案

[三叶题解](https://leetcode.cn/problems/pacific-atlantic-water-flow/solutions/1452108/by-ac_oier-do7d/)

#### 【】[最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

首先遍历各个岛屿，把每个岛屿编号（$grid[i][j]$由1变为当前的编号，编号从2开始），然后在map集合中存入当前编号和面积

之后遍历0的区域，每个点向4个方向寻找周围是否有岛，注意去重（使用set集合维护当前位置已经遍历过的岛的编号）

示意图：

![image-20231121140838781](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231121140838781.png)

#### 【】[单词接龙](https://leetcode.cn/problems/word-ladder/)

双向BFS，[三叶题解](https://leetcode.cn/problems/word-ladder/solutions/831894/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/)

### ==并查集==

![image-20231211111923100](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231211111923100.png)

![image-20231211111932076](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231211111932076.png)

- 除了根节点，其他节点都挂载到根节点下（路径压缩）

```java
private int[] father = new int[200000];
private int node_n;
public void init(){
    for(int i =0;i<node_n;i++){
        father[i] = i;
    }
}

public void join(int u,int v){
    u = find(u);
    v = find(v);
    if(u == v) return;
    father[u] = v;
}

public boolean isSame(int u,int v){
    u = find(u);
    v = find(v);
    return u==v;
}

public int find(int u){
    if(father[u] == u) return u;
    return father[u] = find(father[u]);
}
```

- 路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。

> 了解到这个程度对于求职面试来说就够了。

- 在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。
- 不能用`isSame`替换join中的逻辑，join中最后连接的u,v是u,v的根，调用`isSame`则因为传入的是形参，最后连接的还是u,v，详细解释可见[代码随想录对应章节](https://www.programmercarl.com/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF)的常见误区。

#### 【】[冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

三种情况

情况1和2，有入度为2的节点

![image-20231127164002890](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231127164002890.png)

- 找到入度为2的节点，依次删除指向该节点的两条边，删除之后是树则返回

情况三，没有入度为2的节点，一定出现了环

![image-20231127164046315](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231127164046315.png)

- 找到构成环的边即为要删除的边

```java
class Solution {
    int[] father = new int[1001];
    public void init(){
        for(int i =0;i<1000;i++){
            father[i] = i;
        }
    }

    public int find(int u){
        while(u != father[u]){
            u = father[u];
        }
        return u;
    }

    public boolean isSame(int u,int v){
        u = find(u);
        v = find(v);
        return u == v;
    }

    public void join(int u,int v){
        u = find(u);
        v = find(v);
        if(u == v) return;
        father[u] = v;
    }
    
    public boolean isTreeAfterRemove(int[][] edges,int removeEdge){
        init();
        for(int i = 0;i<edges.length;i++){
            if(i == removeEdge) continue;
            if(isSame(edges[i][0],edges[i][1])) return false;
            join(edges[i][0],edges[i][1]);
        }
        return true;
    }

    public int[] getCircleRemove(int[][] edges){
        for(int i = 0;i<edges.length;i++){
            if(isSame(edges[i][0],edges[i][1])) return edges[i];
            join(edges[i][0],edges[i][1]);
            
        }
        return null;
    }

    public int[] findRedundantDirectedConnection(int[][] edges) {
        init();
        //计算入度
        int m = edges.length,n = edges[0].length;
        int[] indegree = new int[1001];
        for(int i = 0;i<m;i++){
            indegree[edges[i][1]]++;
        }
        List<Integer> edg = new ArrayList<>();
        for(int i = 0;i<m;i++){
            if(indegree[edges[i][1]] == 2){
                edg.add(i);
            }
        }
        if(edg.size() > 0){
            if(isTreeAfterRemove(edges,edg.get(1))){
                return edges[edg.get(1)];
            }else{
                return edges[edg.get(0)];
            }
        }
        return getCircleRemove(edges);

    }
}
```

#### 【】[最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

- [题解](https://leetcode.cn/problems/path-with-minimum-effort/solutions/581494/duo-tu-xiang-xi-fen-xi-jie-ti-si-lu-fen-7z89x/)

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        init();
        //高度差绝对值
        int m = heights.length;
        int n = heights[0].length;
        List<int[]> graph = new ArrayList<>();
        for(int i = 0;i<m;i++){
            for(int j = 0;j<n;j++){
                int pos = i * n + j;
                if(i < m - 1){
                    graph.add(new int[]{Math.abs(heights[i + 1][j] - heights[i][j]),pos,pos+n});
                }
                if(j < n - 1){
                    graph.add(new int[]{Math.abs(heights[i][j + 1] - heights[i][j]),pos,pos+1});
                }
            }
        }
        graph.sort((o1,o2)->o1[0] - o2[0]);
        for(int[] edg : graph){
            join(edg[1],edg[2]);
            if(isSame(0,m * n - 1)){
                return edg[0];
            }
        }
        return 0;
    }
    private int[] father = new int[1000000];
    private int node_n = 1000000;
    public void init(){
        for(int i =0;i<node_n;i++){
            father[i] = i;
        }
    }

    public void join(int u,int v){
        u = find(u);
        v = find(v);
        if(u == v) return;
        father[u] = v;
    }

    public boolean isSame(int u,int v){
        u = find(u);
        v = find(v);
        return u==v;
    }

    public int find(int u){
        if(father[u] == u) return u;
        return father[u] = find(father[u]);
    }
    
}
```

### ==枚举右，维护左==

#### 【23-11-18e1p】[数位和相等数对的最大和](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

- [0x3f题解](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solutions/2531487/mei-ju-you-wei-hu-zuo-pythonjavacgojsrus-eoys/)

- 自己的做法，map和优先队列，闹麻了。

### ==差分数组和前缀和==

[差分优质文章](https://blog.csdn.net/qq_63786973/article/details/127667301)

#### 一维差分的定义与性质

对于数组 a，定义其差分数组（difference array）为

$d[i]=\begin{matrix}a[0],i = 0\\a[i] - a[i-1],i >= 1 \end{matrix}$

- 性质 1：从左到右累加 d 中的元素，可以得到数组 a:$a[i] = sum_{k = 0}^{i}d[k]$

- 性质 2：如下两个操作是等价的。
  - 把 a 的子数组 $a[i],a[i+1],⋯ ,a[j]$都加上x
  - 把 $d[i]$增加x，把$d[j+1]$减少x。

> j= a.length-1的时候 `d[j+1]`就不执行了，因为它的作用主要是保持后续区间值不变，或者差分数组多申请一位，这样不用判断是否j=a.length-1

利用性质 2，我们只需要 $O(1)$的时间就可以完成对 a 的子数组的操作。最后利用性质 1 从差分数组复原出数组 a。

#### 二维差分

在二维差分中，a[ ][ ]是差分数组b[ ][ ]的前缀和，即将原点坐标`(1,1)`和坐标`(i,j)`围成的矩阵中，所有的$b[ ][ ]$相加等于$a[ i ][ j ]$

定义：$ d[i][j] = a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$

还原：$ a[i][j] = a[i-1][j]+a[i][j-1]-a[i-1][j-1]+d[i][j]$

![image-20231214105136250](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231214105136250.png)

一种巧妙的初始化方法是，定义差分矩阵为全零，根据原数组中对应位置的数，进行区域加操作

![image-20231214114346684](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231214114346684.png)

#### 二维前缀和

[0x3f](https://leetcode.cn/circle/discuss/UUuRex/)

![image-20231214104153026](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231214104153026.png)

```java
class MatrixSum {
    private final int[][] sum;

    public MatrixSum(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        sum = new int[m + 1][n + 1]; // 注意：如果 matrix[i][j] 范围很大，需要使用 long
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                sum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + matrix[i][j];
            }
        }
    }

    // 返回左上角在 (r1,c1) 右下角在 (r2-1,c2-1) 的子矩阵元素和（类似前缀和的左闭右开）
    public int query(int r1, int c1, int r2, int c2) {
        return sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1];
    }

    // 如果你不习惯左闭右开，也可以这样写
    // 返回左上角在 (r1,c1) 右下角在 (r2,c2) 的子矩阵元素和
    public int query2(int r1, int c1, int r2, int c2) {
        return sum[r2 + 1][c2 + 1] - sum[r2 + 1][c1] - sum[r1][c2 + 1] + sum[r1][c1];
    }
}
```

#### 【23-12-2每日】[拼车](https://leetcode.cn/problems/car-pooling/)

- [0x3f](https://leetcode.cn/problems/car-pooling/solutions/2550264/suan-fa-xiao-ke-tang-chai-fen-shu-zu-fu-9d4ra/)

#### 【23-12-14每日】[用邮票贴满网格图](https://leetcode.cn/problems/stamping-the-grid/)

- [0x3f](https://leetcode.cn/problems/stamping-the-grid/solutions/1199642/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/)

### ==归纳法==

#### [需要添加的硬币的最小数量](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/)

- [0x3f](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/solutions/2551707/yong-gui-na-fa-si-kao-pythonjavacgo-by-e-8etj/)

### ==KMP==

[代码随想录讲解](https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

- 待补充，自己的理解

```java
class Solution {
    public int[] getNext(String s){
        int n = s.length();
        int[] next = new int[n];
        int j = -1;
        next[0] = j;
        for(int i = 1;i<n;i++){
            while(j >= 0 && s.charAt(j+1) != s.charAt(i)){
                j = next[j];
            }
            if(s.charAt(j+1) == s.charAt(i)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
    public int strStr(String haystack, String needle) {
        //在haystack中找needle
        int n = needle.length();
        if(n == 0) return 0;
        int[] next = getNext(needle);
        int j = -1;
        for(int i = 0;i<haystack.length();i++){
            while(j >= 0 && needle.charAt(j+1) != haystack.charAt(i)){
                j = next[j];
            }
            if(needle.charAt(j+1) == haystack.charAt(i)){
                j++;
            }
            if(j == n-1){
                return i - n + 1;
            }
        }
        return -1;
    }
}
```

### ==滑动窗口==

#### 定长

##### [1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/)

没有情绪控制时候满意的顾客数量，加上以`minutes`为定长滑窗内因为生气惹得不满意顾客的数量

```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int n = customers.length, count = 0, res = 0;
        int count2 = 0;
        for(int i = 0;i<n;i++){
            if(grumpy[i] == 0) count2 += customers[i];
        }
        for(int i = 0;i < minutes;i++){
            if(grumpy[i] == 1){
                count += customers[i];
            }
        }
        res = count;
        for(int i = minutes;i<n;i++){
            if(grumpy[i] == 1) count += customers[i];            
            if(grumpy[i - minutes] == 1) count -= customers[i - minutes];
            res = Math.max(res, count);
        }
        return res + count2;
    }
}
```

##### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

优化思路：使用diff数组，记录不同，可以节省比较的时间

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int sLen = s.length(), pLen = p.length();

        if (sLen < pLen) {
            return new ArrayList<Integer>();
        }

        List<Integer> ans = new ArrayList<Integer>();
        int[] count = new int[26];
        for (int i = 0; i < pLen; ++i) {
            ++count[s.charAt(i) - 'a'];
            --count[p.charAt(i) - 'a'];
        }

        int differ = 0;
        for (int j = 0; j < 26; ++j) {
            if (count[j] != 0) {
                ++differ;
            }
        }

        if (differ == 0) {
            ans.add(0);
        }

        for (int i = 0; i < sLen - pLen; ++i) {
            if (count[s.charAt(i) - 'a'] == 1) {  // 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同
                --differ;
            } else if (count[s.charAt(i) - 'a'] == 0) {  // 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同
                ++differ;
            }
            --count[s.charAt(i) - 'a'];

            if (count[s.charAt(i + pLen) - 'a'] == -1) {  // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同
                --differ;
            } else if (count[s.charAt(i + pLen) - 'a'] == 0) {  // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同
                ++differ;
            }
            ++count[s.charAt(i + pLen) - 'a'];
            
            if (differ == 0) {
                ans.add(i + 1);
            }
        }

        return ans;
    }
}
```

#### 不定长（求最长/最大）

##### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

如果当前区间`[start, i-1]`中存在`s[i]`则需要对左边界进行更新

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int start = -1, n = s.length(),res = 0;
        if(n <= 1) return n;
        HashMap<Character,Integer> map = new HashMap<>();
        for(int i= 0;i<n;i++){
            if(map.containsKey(s.charAt(i))){
                start = Math.max(start,map.get(s.charAt(i)));
            }
            map.put(s.charAt(i),i);
            res = Math.max(res,i - start);
        }
        return res;
    }
}
```

##### [2730. 找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/)

![image-20240415190030989](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240415190030989.png)

```java
class Solution {
    public int longestSemiRepetitiveSubstring(String S) {
        var s = S.toCharArray();
        int ans = 1, left = 0, same = 0, n = s.length;
        for (int right = 1; right < n; right++) {
            if (s[right] == s[right - 1] && ++same > 1) {
                for (left++; s[left] != s[left - 1]; left++);
                same = 1;
            }
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```

#### 不定长（求最短/最小）

##### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

和求最长的相比，对于左侧的更新有所变化

- 求最长的更新：区间不满足条件之后，逐个去除左侧值并更新左区间，直到满足
- 求最短的更新：只要把最左边去了之后还满足，就把最左边的值去除

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length, left = 0, right = 0, res = n + 1;
        int sum = 0;
        while(right < n){
            sum += nums[right];
            while(sum - nums[left] >= target) sum -= nums[left++];
            if(sum >= target) res = Math.min(res, right - left + 1);
            right++;
        }
        return res == n + 1? 0 : res ;
    }
}
```

#### 求子数组个数

##### [2799. 统计完全子数组的数目](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/)

 0x题解，精华：用`ans += left`来更新答案，不是每次遇到满足的区间后计数

这是建立在完全子数组的定义上的，即：子数组中 **不同** 元素的数目等于整个数组不同元素的数目

子数组已经到达了不一样元素数目的最大值，而在循环中`[left,right]`正好是第一个以right为右端点不满足的区间，以left左侧为端点则都满足

同时，这些左端点对右侧更大的右端点构成的区间也满足完全子数组的要求

```java
class Solution {
    public int countCompleteSubarrays(int[] nums) {
        var set = new HashSet<Integer>();
        for (int x : nums) set.add(x);
        int m = set.size();
        var cnt = new HashMap<Integer, Integer>();
        int ans = 0, left = 0;
        for (int v : nums) { // 枚举子数组右端点 v=nums[i]
            cnt.merge(v, 1, Integer::sum);
            while (cnt.size() == m) {
                int x = nums[left++];
                if (cnt.merge(x, -1, Integer::sum) == 0)
                    cnt.remove(x);
            }
            ans += left; // 子数组左端点 < left 的都是合法的
        }
        return ans;
    }
}
```

##### [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int n = nums.length, left = 0, right = 0, res = 0;
        if(k <= 1) return res;
        int count = 1;
        while(right < n){            
            count = count * nums[right]; 
            while(count >= k){
                count /= nums[left++];
            }
            res += right - left + 1;
            right++;
        }
        return res;
    }
}
```

#### 多指针滑动窗口

##### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)

因为题中的数据都是0和1，所以当left1左移使得`count1 > goal`不成立的时候，正好有`count1 = goal`，然后left2右移，直到`count2 < goal`，这个时候，在当前right下`[left1, left2)`区间中都是符合条件的

```java
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length, left1 = 0, left2 = 0, right = 0,res = 0;
        int count1 = 0, count2 = 0;
        while(right < n){
            count1 += nums[right];
            while(left1 <= right && count1 > goal){
                count1 -= nums[left1++];
            }
            count2 += nums[right];
            while(left2 <= right && count2 >= goal){
                count2 -= nums[left2++];
            }
            res += left2 - left1;
            right++;
        }
        return res;
    }
}
```

这道题可能是一种更清晰的多指针窗口题目：[1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

### ==多线程==

#### 交替打印输出

```java
public class Main {
    private static Object lock = new Object();
    private static boolean flag = true;
    public static void main(String[] args) {
        Thread thread1 = new Thread(()->printA());
        Thread thread2 = new Thread(()->printB());
        thread1.start();
        thread2.start();
    }
    public static void printA(){
        synchronized (lock){
            while(true){
                while(!flag){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                System.out.println("A");
                flag = false;
                lock.notify();
            }
        }
    }
    public static void printB(){
        synchronized (lock){
            while (true){
                while(flag){
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                System.out.println("B");
                flag = true;
                lock.notify();
            }
        }
    }
}
```

> 获取到锁之后再进行`while(true)`循环比较好？

### ==其他==

#### [LCR 168. 丑数](https://leetcode.cn/problems/chou-shu-lcof/)

- 每个丑数都可以由其他较小的丑数通过乘以 2 或 3 或 5 得到
- [krahets](https://leetcode.cn/problems/chou-shu-lcof/solutions/182045/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/)

```java
class Solution {
    public int nthUglyNumber(int n) {
        int a = 0, b = 0, c = 0;
        int[] res = new int[n];
        res[0] = 1;
        for(int i = 1; i < n; i++) {
            int n2 = res[a] * 2, n3 = res[b] * 3, n5 = res[c] * 5;
            res[i] = Math.min(Math.min(n2, n3), n5);
            if (res[i] == n2) a++;
            if (res[i] == n3) b++;
            if (res[i] == n5) c++;
        }
        return res[n - 1];
    }
}
```

#### [2735. 收集巧克力](https://leetcode.cn/problems/collecting-chocolates/)

[官解1](https://leetcode.cn/problems/collecting-chocolates/solutions/2580148/shou-ji-qiao-ke-li-by-leetcode-solution-bjyp/)

####  [2645. 构造有效字符串的最少插入数](https://leetcode.cn/problems/minimum-additions-to-make-valid-string/)

统计有多少组'abc'，如果一个数的ascii值比它左边的数小，那么就需要有一个新的'abc'来包含这个数

```java
class Solution {
    public int addMinimum(String word) {
        int n = word.length();
        int count = 1;
        for(int i = 1;i<n;i++){
            if(word.charAt(i) <= word.charAt(i-1)){
                count++;
            }
        }
        return 3 *count - n;

    }
}
```

#### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

`LinkedHashMap`：能够保证元素的FIFO

```java
public class LRUCache {
    private final int capacity;
    private final Map<Integer, Integer> cache = new LinkedHashMap<>(); // 自带双向链表

    public LRUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) { // key 不在 cache 中
            return -1;
        }
        int value = cache.remove(key);
        cache.put(key, value); // 把 key 移到链表末尾
        return value;
    }

    public void put(int key, int value) {
        if (cache.remove(key) != null) { // key 在 cache 中
            cache.put(key, value); // 把 key 移到链表末尾
            return;
        }
        if (cache.size() == capacity) { // cache 满了
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey); // 移除最久未使用 key
        }
        cache.put(key, value);
    }
}
```

```java
//自己实现双向链表
class LRUCache {
    private static class Node{
        int key, value;
        Node prev, next;

        Node(int k, int v){
            key = k;
            value = v;
        }
    }

    private final int capacity;
    private final Node dummy = new Node(0, 0); // 哨兵节点
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummy.prev = dummy;
        dummy.next = dummy;    
    }
    
    public int get(int key) {
        Node node = getNode(key);
        return node == null ? -1 : node.value;
    }
    
    public void put(int key, int value) {
        Node node = getNode(key);
        if(node != null){
            node.value = value;
            return;
        }
        node = new Node(key, value);
        keyToNode.put(key, node);
        pushFront(node);
        if(keyToNode.size() > capacity){
            Node backNode = dummy.prev;
            remove(backNode);
            keyToNode.remove(backNode.key);
        }
    }

    private Node getNode(int key){
        if(!keyToNode.containsKey(key)){
            return null;
        }
        Node node = keyToNode.get(key);
        remove(node);
        pushFront(node);
        return node;
    }

    private void remove(Node x){
        x.prev.next = x.next;
        x.next.prev = x.prev;
    }

    private void pushFront(Node x){
        x.prev = dummy;
        x.next = dummy.next;
        x.next.prev = x;
        x.prev.next = x;
    }   
}
```

#### [整数回文判断（不转字符串）](https://leetcode.cn/problems/palindrome-number/)

```java
class Solution {
    public boolean isPalindrome(int x) {
        if(x < 0 || (x % 10 == 0 && x != 0)) return false;
        int remain = x;
        int build_new = 0;
        while(remain > build_new){
            build_new = 10 * build_new +  remain % 10;
            remain /= 10;
        }
        return remain == build_new || remain == build_new / 10;
    }
}
```

-  特殊情况：

  -  如上所述，当 x < 0 时，x 不是回文数。同样地，如果数字的最后一位是 0，为了使该数字为回文，则其第一位数字也应该是 0只有 0 满足这一属性

    > 不判断最后一位是0的情况，过不了用例`10`，可以简单推演一下原因

- 对于奇数的情况，build_new应该比remain多一位，最后去掉即可

#### [1146. 快照数组](https://leetcode.cn/problems/snapshot-array/)

一个类似数据库MVCC设计的题，最优的解是用二分找对应快照号，使用`TreeMap`偷鸡

在每次set，即进行值更改的时候，更新版本链

对每一个位置，都使用`HashMap`来保存它值变化的版本链信息，即key是`index`,value是该位置的版本链变化信息

```java
class SnapshotArray {
    private int snap_id;
    private HashMap<Integer, TreeMap<Integer, Integer>> snap_map;
    public SnapshotArray(int length) {        
        snap_map = new HashMap<>();
        snap_id = 0;
    }
    
    public void set(int index, int val) {
        TreeMap<Integer, Integer> snapshot = snap_map.getOrDefault(index, new TreeMap<>());
        snapshot.put(snap_id, val);
        snap_map.put(index, snapshot);
    }
    
    public int snap() {
        return snap_id++;
    }
    
    public int get(int index, int snap_id) {
        TreeMap<Integer, Integer> snapIdToValue = snap_map.getOrDefault(index, new TreeMap<>());
        Map.Entry<Integer, Integer> ans = snapIdToValue.floorEntry(snap_id);
        if(ans == null){
            return 0;
        }
            
        return ans.getValue();
    }
}

/**
 * Your SnapshotArray object will be instantiated and called as such:
 * SnapshotArray obj = new SnapshotArray(length);
 * obj.set(index,val);
 * int param_2 = obj.snap();
 * int param_3 = obj.get(index,snap_id);
 */
```

#### [1017. 负二进制转换](https://leetcode.cn/problems/convert-to-base-2/)

![image-20240428133748447](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240428133748447.png)

![image-20240428133800949](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240428133800949.png)

评论区思路：

![image-20240428142037726](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240428142037726.png)

```java
class Solution {
    public String baseNeg2(int n) {
        if (n == 0 || n == 1) {
            return String.valueOf(n);
        }
        StringBuilder res = new StringBuilder();
        while (n != 0) {
            int remainder = n & 1;
            res.append(remainder);
            n -= remainder;
            n /= -2;
        }
        return res.reverse().toString();
    }
}
//对应思路2
class Solution {
    public String baseNeg2(int n) {
        if (n == 0 || n == 1) {
            return String.valueOf(n);
        }
        StringBuilder res = new StringBuilder();
        while (n != 0) {
            int remainder = n % (-2);
            n /= -2;
            if(remainder == -1){
                remainder = 1;
                n++;
            }
            res.append(remainder);
            
        }
        return res.reverse().toString();
    }
}

```

> 注意到java中的`14/-3 == -4 `这实际是向上取整，向下取整的值应该是-5

#### [面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

经典分治问题

B是一个中间态，如果就有一个，直接A->C就行了

如果有多个，先放i-1个到B，然后放一个到C

然后给B的再放回C

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        sub(A, B, C, A.size());
    }
    private void sub(List<Integer> A, List<Integer> B, List<Integer> C, int i){
        if(i == 1){
            move(A,C);
            return;
        }
        sub(A, C, B, i - 1);
        move(A, C);
        sub(B, A, C, i - 1);

    }
    private void move(List<Integer> A, List<Integer> C){
        Integer temp = A.remove(A.size() - 1);
        C.add(temp);
    }
}
```

傻逼做法，模拟

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        while(A.size() > 0){
            //取出来的放C，然后B上的放C之后一起搬到B
            int move2c = A.get(A.size() - 1);
            A.remove((int)(A.size() - 1));
            C.add(move2c);
            while(B.size() > 0){
                C.add(B.get(B.size() - 1));
                B.remove((int)(B.size() - 1));
            }
            while(C.size() > 0){
                B.add(C.get(C.size() - 1));
                C.remove((int)(C.size() - 1));
            }
        }
        while(B.size() > 0){
            C.add(B.get(B.size() - 1));
            B.remove((int)(B.size() - 1));
        }
    }
}
```

### 常用操作

#### 数据结构结构定义

```java
//链表
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}

//二叉树
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
 
//图邻接矩阵
int[][] g = new int[n][n];

//图邻接表
List<int[]>[] g = new ArrayList[n];
```

#### 流操作

```java
//列表求均值
double average = temp.stream()
                        .mapToInt(Integer::intValue)
                        .average()
                        .orElse(0.0);
```

#### map的添加和合并

[merge api](https://doc.qzxdp.cn/jdk/17/en/api/java.base/java/util/HashMap.html#merge(K,V,java.util.function.BiFunction))

```java
V public V merge(K key, V value,
                 BiFunction<? super V,? super V,? extends V> remappingFunction)
//the new value associated with the specified key, or null if no value is associated with the key

map.merge(number,1,Integer::sum);
//有该key的话用new value = value+1
//否则value = 0 + 1
//减操作可以用
map.merge(number,-1,Integer::sum);
//但是要注意，当Key不存在的时候会产生-1
```

#### map初始化

```java
Map<String, String> map = new HashMap<String, String>(Map.of("2","abc", "3", "def",
    "4","ghi","5","jkl","6","mno","7","pqrs","8","tuv","9","wxyz"));
//对key-value的数量有要求，不超过10对
```

#### 原地旋转相关

- 原地旋转字符串等

  - 左旋n位

    - 反转区间为前n的子串
    - 反转区间为n到末尾的子串
    - 反转整个字符串

    左旋四位

    <img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231212212235460.png" alt="image-20231212212235460" style="zoom:50%;" />

    明显，上边总长为7的字符串，左旋四位与右旋三位等价

    ![image-20231212213043750](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231212213043750.png)

  - 右旋n位

    - 反转整个字符串
    - 反转区间为前n的子串
    - 反转区间为n到末尾的子串

<img src="https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231212212619667.png" alt="image-20231212212619667" style="zoom:50%;" />

#### 数学组合数（$C_{n}^{k}$）

$C_{n}^{k} = A_{n}^{k}/A_{n}^{n} = n * (n - 1) *...*(n - k + 1) / n! = \prod_{i=0}^{k -1}(n-i) / n!$

```java
// 适用于 n 和 k 都比较小的场景（本题至多 26）
private long comb(long n, int k) {
    long res = n;
    for (int i = 2; i <= k; i++)
        res = res * --n / i; // n,n-1,n-2,... 中的前 i 个数至少有一个因子 i
    return res;
}

private int comb(int n, int k) {
    if (k == 0 || k == n) {
        return 1;
    }
    return comb(n - 1, k - 1) + comb(n - 1, k);
}

//dp
public long comb(int n, int k) {
        long[][] dp = new long[n + 1][k + 1];
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i <= k; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= k; j++) {
                if (j <= i) {
                    if (j == 0 || j == i) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                    }
                }
            }
        }
        return dp[n][k];
}
```
> 需要注意的是，如果for中没有if判断，那么会产生问题：`$dp[3][3] = dp[2][2] + dp[2][3]`但是，`dp[2][3]`对应的$C_{2}^{3}$是不具有意义的
>
> 我们应该尽早的去除i小于j的情况，优化后如下
```java
public long comb(int n, int k) {
        long[][] dp = new long[n + 1][k + 1];
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i <= k; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < Math.min(i+1,k); j++) {
                if(j == i) dp[i+1][j+1] = 1;
                else dp[i+1][j+1] = dp[i][j] + dp[i][j + 1];
            }
        }
        return dp[n][k];
}
```


#### 矩阵快速幂[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

```java
//迭代
public double myPow(double x, int n) {
        double res = 1.0;
        int flag = n > 0?1:-1;
        while(n != 0){
            if(n % 2 != 0){
                res *= x;
            }
            x *= x;
            n /= 2;
        }
        return Math.pow(res,flag);
}

//仅仅针对正数的
private long pow(long x, int n) {
        long res = 1;
        for (; n > 0; n /= 2) {
            if (n % 2 > 0)
                res = res * x % MOD;
            x = x * x % MOD;
        }
        return res;
}

//递归
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x,N):1.0 / quickMul(x,-N);
    }
    public double quickMul(double x,long N){
        if(N == 0){
            return 1.0;
        }
        double y = quickMul(x,N/2);
        return N % 2 == 0 ? y * y :y * y * x;
    }
}
```

#### 快速乘法

以13\*27为例：

乘法的本质是加法，13\*27可以转化为27个13相加（或13个27相加）

快速乘法：

将27转化为二进制：

$27=(11011)_{2}=1∗2^{4}+1∗2^{3}+0∗2^{2}+1∗2^{1}+1∗2^{0}=16+8+2+1$

式子转化为：

$13⋅27=13⋅(16+8+2+1)=13⋅16+13⋅8+13⋅2+13⋅1$

```java
long mul(long a, long k) {
    long ans = 0;
    while (k > 0) {
        if ((k & 1) == 1) ans += a;
        k >>= 1;
        a += a; //模拟2的多少次方
    }
    return ans;
}
```
#### 模运算

![image-20231210225439541](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231210225439541.png)

#### 整数上取整

`(a + b - 1) / b`

- 如果`a % b != 0` 说明不能整除，余数至少是1，进行`+b-1`操作正好满足往上补1的最低要求（即只余了1）
- 如果`a % b == 0`，说明能够整除，此时`-1`操作又保证了，不会向上多1

#### `TreeMap`的使用

能够排序的map

```java
Map.Entry<K,V> floorEntry(K key)
//Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
//返回小于等于给定key的最大Map.Entry
K floorKey(K key)
//Returns the greatest key less than or equal to the given key, or null if there is no such key.
Map.Entry<K,V> firstEntry()
//Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
```

#### 输出格式的限定

`System.out.printf()`

`%d`: 整数

`%f`: 浮点数

`%s`: 字符串

`%10d`: 输出宽度为10的整数，右对齐。

`%-10d`: 输出宽度为10的整数，左对齐。

`%10.2f`: 输出宽度为10，保留两位小数的浮点数。

`%10s`: 输出宽度为10的字符串，右对齐。

`%-10s`: 输出宽度为10的字符串，左对齐。

#### 字符串根据一个或者多个空格进行分割

```java
String test = "I have    a dream    ";
String[] test_list = test.split("\\s+");
```

使用了正则表达式，`\\s+`表示匹配任何非空白字符出现一次或多次

#### 随机数操作

```java
// 构造函数(一)： 创建一个新的随机数生成器。 
 
Random() 
// 构造函数(二)： 使用单个 long 种子创建一个新随机数生成器： public Random(long seed) { setSeed(seed); } next 方法使用它来保存随机数生成器的状态。
Random(long seed) 
 
boolean nextBoolean()     // 返回下一个“boolean类型”伪随机数。 
void  nextBytes(byte[] buf) // 生成随机字节并将其置于字节数组buf中。 
double nextDouble()     // 返回一个“[0.0, 1.0) 之间的double类型”的随机数。 
float  nextFloat()      // 返回一个“[0.0, 1.0) 之间的float类型”的随机数。 
int   nextInt()       // 返回下一个“int类型”随机数。 
int   nextInt(int n)    // 返回一个“[0, n) 之间的int类型”的随机数。 
long  nextLong()      // 返回下一个“long类型”随机数。 
  
synchronized double nextGaussian()  // 返回下一个“double类型”的随机数，它是呈高斯（“正常地”）分布的 double 值，其平均值是 0.0，标准偏差是 1.0。 
synchronized void setSeed(long seed) // 使用单个 long 种子设置此随机数生成器的种子。
```

#### 相交区间判断与计算

如果有两个区间[a, b]和[c, d]，判断两个区间不想交的情况（a > d 或者 c > b）

但是这样对于重叠部分的计算不那么容易

我们可以选max(a, c)作为左端点left，min(b, d)作为右端点right，如果有重叠部分，那么right一定会大于left，同时left-right就是重叠部分的取值

# :clock1:

- 使用归并解决[148. 排序链表](https://leetcode.cn/problems/sort-list/)
