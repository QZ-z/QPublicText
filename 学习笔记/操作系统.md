[toc]

注：有关代码部分可以参考书中讲解，书中十分细致。

# :one: 操作系统基础

## 计算机的启动

[cc1.2 开始揭开钢琴的盖子.pdf](C:\Users\Administrator\Documents\WPSDrive\288631305\WPS云盘\java学习\操作系统\第1章 操作系统基础\cc1.2 开始揭开钢琴的盖子.pdf) 

![image-20231227142558231](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227142558231.png)

在启动盘中的操作系统程序，要按照上述的组织形式来完成

```assembly
SETUPLEN = 4				! nr of setup-sectors
BOOTSEG  = 0x07c0			! original address of boot-sector
INITSEG  = 0x9000			! we move boot here - out of the way
SETUPSEG = 0x9020			! setup starts here
SYSSEG   = 0x1000			! system loaded at 0x10000 (65536).	
ENDSEG   = SYSSEG + SYSSIZE		! where to stop loading
```

![image-20231227145445927](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227145445927.png)

现在cs:ip指向的地址为0x7c00，即将bootsect.s读入的地址

> 读入的这个扇区也叫做引导扇区，是启动设备的第一个扇区，硬盘中一个扇区是512Bytes

### 引导扇区bootsect.s完成的工作

总结：

- 将bootsect移动到安全的位置
- 读入setup和system
- 跳转到setup执行

![image-20231227145729217](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227145729217.png)

移动的是256个字，即正好是512个字节，一个磁盘扇区的长度，执行完这段代码pc指向0x9000:0x0200

> 为什么要进行这样的移动，见setup部分

![image-20231227150107377](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227150107377.png)

ds=0x9000, es=0x9000, ss=0x9000, sp=0xff00, bx=0x0200

dx=0x0000 ，cx=0x0002，读入从0柱面，0磁头，2扇区开始的四个扇区，正好是setup的四个扇区

![image-20231227151458141](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227151458141.png)

![image-20231227151537471](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227151537471.png)

对于本文的linux0.11，SYSSIZE=0x8000

> SYSSEG指示system模块开始的地址，SYSSIZE指示当前system模块的长度，ENDSEG指示读入的结束

### setup.s完成的工作

总结：

- 读入一些硬件参数
- 进入保护模式
- 执行32位汇编指令跳转到system起始位置

![image-20231227155331843](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227155331843.png)

`INITSEG= 0x9000`，`ds=0x9000`，[2]的寻址方式默认使用的段寄存器是ds

setup段开始的内存为`0x9000:0x0200`，一共有4个扇区，有==4*512Bytes = 2^11^Bytes==，所以所以setup段的地址范围是：`0x9000:0x0200`-`0x9000:0x09FF`

do_move里边：`es = 0x0000 ,ds = 0x1000`

`movsw`一次传送一个字，源地址是`DS:SI`,目的地址是`ES:DI`，之后`SI`和`DI`(或者`ESI`和`EDI`)加/减`2`

do_move循环8次，每次移动`0x8000`个字，一共移动==2^3^  *2 * 2^15^ Bytes = 2 ^19^ Bytes==即大小为0x80000字节

注意将system模块移动到0地址的时候，移动了`0x8000`个字，即`0x10000`个字节 ，所以在最开始，要将`0x07c0:0x0000`处的代码移动到`0x9000:0x0000`处，防止因操作系统代码过长导致bootsect和setup部分被覆盖

> 为什么要从0x10000开始读，setup段和后面的系统段是连续的么？
>
> 答：因为system读入内存中，从0x10000开始，这么setup段是从0x90200开始的4个字节，这么看来，setup段和system部分中间会有一部分空闲空间。

![image-20231227211711976](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227211711976.png)

setup在最后会使得系统进入保护模式，寻址方式也将发生改变，从16位模型切换到32位模式

> cs，ip都是16位的寄存器，cs左移4位加ip，最多访问1M内存，太少了

GDP(Global Descriptor Table)，全局描述符表

IDT(Interrupt Descriptor Table)，中断描述符表

> 拓展：[中断向量表和IDT的区别](https://blog.csdn.net/yxc135/article/details/8734452)

![image-20231227212042250](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227212042250.png)

![image-20231227212657295](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227212657295.png)

上述就是==gdt表的初始化==部分，因为是按照字节寻址，所以第二行的开始地址是8，`jmpi 0,8`查找的就是这个表项

![image-20231227213616537](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227213616537.png)

将三部分段基址拼完之后，获得的段基址为：`0x0000000`，即jmp到内存`0x0000处`，是system开始的地方

### system模块

#### 第一部分代码head.s

![image-20231227214450012](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227214450012.png)

需要自己连接文件，控制system的第一部分是head.s，同时也要控制整体的结构和下述结构相同

![image-20231227142558231](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227142558231.png)

再次初始化了GDT和IDT表，之前`jmpi 0,8`只是短暂使用GDT表

![image-20231227215159218](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227215159218.png)

操作系统中用到的汇编有三种形式：

![image-20231227215142232](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227215142232.png)

head.s最后应该跳转到main.c 

![image-20231228203000490](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228203000490.png)

> 扩展：[c语言函数调用的栈帧变化](https://blog.csdn.net/kangkanglhb88008/article/details/89739105)

![image-20231228203049721](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228203049721.png)

main应该永远不会退出，开机之后，操作系统应该一直在运行

![image-20231228203136062](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228203136062.png)

上述代码完成了对内存的初始化，0表示空闲内存，开始部分被占用内存中是操作系统

参数来自setup.s存入0x90002中的扩展内存大小

## 操作系统接口

![image-20231228204041526](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228204041526.png)

POSIX：可移植操作系统接口

## 系统调用

![image-20231228204208621](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228204208621.png)

`DPL>=CPL`即当前只能访问隔离等级比自己低的部分

==系统调用的核心==：

- 用户程序中包含一段有int指令的代码
- 操作系统写中断处理，获取想调用程序的编号
- 操作系统根据编号执行相应代码

<img src="http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228205149851.png" alt="image-20231228205149851" style="zoom:50%;" />

使用printf函数的系统调用过程见上图，下图展示了其中蕴含的状态切换

![image-20231228212602929](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228212602929.png)

==通过printf的执行过程来了解系统调用==

![image-20231228205348159](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228205348159.png)

![image-20231228210117341](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228210117341.png)

![image-20231228205503375](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228205503375.png)

按照宏汇编，`type = int ,name = write,atype = int ,btype = fd ,ctype = const char *`

实际的函数调用为`int write(int a ,fd b ,const char *c)`

`__NR_write`的值给eax，第一，二，三个参数分别给ebx，ecx，edx，同时eax也用来之后存放返回值

### int 0x80中断处理 

int指令将使CS中的CPL改成0，进入内核

![image-20231227130245899](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227130245899.png)



访问的IDT中的DPL被设置为3，所以最开始处于用户态的代码可以对此进行访问，之后重新设置地址之后，CS=8，其中CS的最低两位是CPL的值，即此刻CPL值为0，代码进入<font color= red>核心态</font>

中断返回之后，CPL被置为3，重新返回用户态

处理0x80中断之后CS=8，IP的值为 `&system_call`，即接下来执行`system_call`部分

![image-20231228211740527](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228211740527.png)

`_sys_call_table`是起始位置，因为每个系统调用对应的函数指针（在32位系统中，函数指针占4个字节，寻址32位）占4个字节，所以是`4 * %eax`，其中eax中存放的是系统调用号

![image-20231228212523122](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228212523122.png)

![image-20231227131235866](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231227131235866.png)



不能通过左图的直接调用内核的部分，按照右图中的方法通过中断，进入内核态来调用对应的部分

## 操作系统历史

见pdf

OS360只有在遇到特别费时的IO操作的时候，才会切换任务，MULTICS对于任务的切换更加的灵活

# :two: 进程与线程

[他人笔记参考](https://blog.csdn.net/qq_41094332/article/details/124304764)

## 引入

![image-20240101181818038](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101181818038.png)

![image-20240101182155977](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101182155977.png)

> 一旦程序运行起来，就需要记录程序运行期间的各种信息，所以和静态程序不一样了
>
> 要记录切换到程序2时程序1的状态，这就需要PCB（进程控制块，Process Control Block）

进程是进行（执行）中的程序

- 进程有开始、有结束，程序没有
- 进程需要记录ax,bx,…，程序不用
- 进程会走走停停，走停对程序无意义

## 多进程图像

操作系统把进程记录好、要按照，合理的次序推进(分配资源、进行调度)，这就是==多进程图像==

![image-20240101183831007](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101183831007.png)

![image-20240101184330083](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101184330083.png)

![image-20240101184615776](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101184615776.png)

> 疑问：进程状态图和线程状态图有什么异同？

![image-20240101184951589](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101184951589.png)

> `schedule()`完成进程的切换
>
> `getNext()`获得队列中的下个进程
>
> `switch_to()`的两个参数是PCB中对不同进程的标识

![image-20240101185258465](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101185258465.png)

![image-20240101185559334](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101185559334.png)

从进程1切换到进程2：把物理CPU中的值存放到PCB1中，之后将PCB2中的值放到物理CPU中

![image-20240101185812059](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101185812059.png)

![image-20240101190025924](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101190025924.png)

进程1的映射表将访问限制在进程1范围内，进程1根本访问不到其他进程的内容，这是内存管理的内容

![image-20240101190259177](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101190259177.png)

经典的一个合作例子就是：生产者-消费者

> 核心在于==进程同步==

## 用户级线程

![image-20240101191316982](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240101191316982.png)

线程共用一个映射表，而进程则是各有各的映射表

因为线程切换的时候映射表并未发生变化，相比进程来说，线程的切换的代价较小

![image-20240102134304660](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102134304660.png)

这种由多个线程处理不同的资源，但所有的资源都是在一个屏幕上显示的浏览器就是一个很好的多执行，单地址的用例。

![image-20240102134509145](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102134509145.png)

![image-20240102134803319](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102134803319.png)

![image-20240102134951017](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102134951017.png)

两个执行序列，但是只有一个栈，所有的返回地址都在一个栈中，造成返回地址错误。（3）执行完毕之后，栈顶的地址是404，但实际上应该的返回地址的104。

![image-20240102135200722](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102135200722.png)

存在`jmp 204`的时候，跳转到204之后，（3）向下遇到右括号，要根据栈顶寻找下一个执行地址，还是204，出错，所以`jmp 204`不应存在，`Yield()`执行完之后，直接通过ret指令跳转

![image-20240102140121557](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102140121557.png)

![image-20240102140322514](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102140322514.png)

![image-20240102140424742](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102140424742.png)

如果在内核阻塞，那么用户级线程是不能够感知内核的阻塞事件的，也不会转去执行其他的线程

![image-20240102140528177](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102140528177.png)

> 内核级线程的切换代价较大，因为需要进行模式切换和内核调度
>
> 图片中的yield实际上是Schedule

核心级线程则没有这个问题，核心级线程的`ThreadCreate`是一个系统调用，要创建这个线程会进入到内核中创建，内核可以感知到该线程的存在。若该线程被阻塞了，操作系统可以切换到另一个核心级线程进行执行，而不至于让一个进程中的所有线程都被阻塞。因此，设置内核级线程可以增强线程的并发性。

为了与`yield`（用户主动释放）区分开来，用`schedule`（操作系统调度）来实现线程的切换，而`shcedule`完全不可见是由操作系统决定的。

## 内核级线程

并发和并行：

- 并发是逻辑上的同时发生（simultaneous）
- 并行是物理上的同时发生

> 拓展：[并发和并行的区别](https://blog.csdn.net/scarificed/article/details/114645082)

内核栈中的EFLAGS

![image-20240102141252711](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102141252711.png)

对于多处理器的情况，内核级线程其实是无效的，因为无论如何都要对地址进行切换，但是对于多核的情况却是十分的适配。多核共享一套地址，但是有多个核心来处理不同的程序。

![image-20240102141525568](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102141525568.png)

![image-20240102141612159](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102141612159.png)

EFLAGS：标志寄存器

进入内核的唯一方法是中断，只要进入内核时，就会进入内核栈。

一旦INT指令触发后，就会通过计算机硬件上的寄存器来找到此时的线程所对应的内核栈。然后，就会将刚才用户所执行的用户栈的`SS`和`SP`信息压入内核栈。同时，也会将刚才的`PC`和`CS`信息压入内核栈，即把刚才在用户态所执行的地方压入内核栈。内核栈通过指针把两个栈拉在一起。

与之相对的是执行IRET指令时，就会将内核栈的数据弹出，又会退回到用户栈，即回到之前在用户态下所执行的地方


![image-20240102141645962](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102141645962.png)

栈顶的1000是`system_call`之后的返回地址

![image-20240102141930813](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102141930813.png)

<img src="http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102142623024.png" alt="image-20240102142623024" style="zoom:50%;" />

S的内核栈栈顶，应该是`sys_read()`中的某个地方，即存放的是一个返回地址

T内核栈中，PC和CS标识了产生interrupt之前的地址，CS=500, PC = 3000

T内核栈栈顶，存放了一段能够完成二级返回的代码（一段包含了iret的代码）

> 通过ret切换到某个内核程序：等同于之前用户级线程中`Yield()`执行完毕，通过`ret`跳转到下一步运行的地址。
>
> 切换到**线程T**后，它在内核态执行完一小段后，就又会切换到用户态下执行对应的用户线程。

![image-20240102142227339](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102142227339.png)

引发切换之后`schedule()`寻找下一个线程对应的TCB

![image-20240102144442474](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102144442474.png)

`ThreadCreate`

- 完成用户栈和内核栈的关联
- 完成内核栈和TCB的关联

![image-20240102144603186](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102144603186.png)

## :star:内核级线程实现

进程实际上由两部分组成，一部分是**资源**，另一部分是**执行序列**，而里面的执行序列实际上就是**线程**。进程又必须进入到内核，所以**进程里面的执行序列**就是**内核级线程**。所以，学会了内核级的代码代码实现，也就掌握了大部分的进程实现。再加上后面的资源管理部分，就在操作系统上实现进程。

> 进程为什么必须进入内核？

![image-20240102185938694](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102185938694.png)

上图是对5段论的一个总结

![image-20240102192106835](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102192106835.png)

执行A的时候，会向用户栈中压入返回地址（即B的位置）。在A中遇到`fork()`后触发`0x80`中断。

一旦触发80中断后，CPU就会马上找到**当前的内核栈**，压入当前的`ss`和`sp`以及`cs`和`ip`（`int 0x80`后一句代码的位置**），即用户栈与程序执行的位置信息。然后进入到**中断处理函数，将`system_call`压入内核栈中。

![image-20240102192450944](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102192450944.png)

![image-20240102193410835](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102193410835.png)

==中断入口==：

```assembly
_system_call:
	push %ds .. %fs
	pushl %edx...
	call sys_fork
	pushl %eax
```

`_system_call`中依然是压栈，把刚才在用户态中的寄存器里的数据在核心态中下记录下来。（当将来再用这些内容时，可以再弹出去）

记录完后，执行之前用户程序所需要的系统调用函数`sys_fork`。而在执行`sys_fork`时，可能会引起切换，因为当内核程序在内核中执行时，可能会因为某些原因导致当前线程阻塞，来引发切换，这也就是五段论中的中间三段。
==中间三段==：

```assembly
movl _current, %eax
cmpl $0, state(%eax)
jne reschedule
cmpl $0, counter(%eax)
je reschedule
ret_from_sys_call:
```

当`sys_fork`执行完后，再往下执行时，会将`_current`（当前线程的TCB）置给`eax`，然后判断当前线程的`state`（实际上就是` state+eax = state+_current = state+TCB`），实际上就是用`cmpl`判断当前线程PCB中的`state`是否等于0。

- 如果等于0，则表示为运行态，不会执行`jne`指令进行调度；
- 如果不等于0，表示为阻塞状态，就会通过`jne`指令（不相等则跳转，ZF=0时执行该语句）进行调度`reschedule`进行执行，`reschedule`会完成内核级线程的切换，即五段论中的中间三步。

再用`cmpl`判断`_current`的`counter`是否等于0，如果等于0，则执行`je`指令（相等则跳转）进行调度，而`counter`所记录的实际上就是时间片，等于0表示时间片已经用光。

> 上述两个跳转指令，分别用于判断状态和时间片，来决定是否去reschedule中执行schedule函数。
>
> - 如果当前的状态不为运行态，则进行调度。
> - 如果当前线程的时间片已经用光，则也进行调度。

==中断出口==：

```assembly
reschedule:
	pushl $ret_from_sys_call
	jmp _schedule
```

进入到`reschedule`后，首先会把切换前的线程的返回地址存入到栈中，然后再去执行`shcedule`。一旦切换完成（`schedule`执行完后），接下来就又会跳回到这个函数的下一条语句`ret_from_sys_call`，执行中断返回。

```assembly
ret_from_sys_call:
	popl %eax // 返回值 popl %ebx ...
	pop %fs ...
	iret // 重要
```

跳转到返回地址后，执行该语句。中断出口，切换到刚才调度的内核线程。

按照之前`push`的逆序顺序进行`pop`存入到对应的寄存器当中。最后，再执行`iret`将`ss`和`sp`以及`cs`和`ip`一起`pop`出去后，就会执行之前产生中断，并发生系统调度之前的用户程序。

![image-20240102194902060](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102194902060.png)

其中`TR`是当前`CPU`对应的任务段的描述符所存在于**GDT表**中的地址位置，类似于`CS`；

`_TSS(n)`中的参数`n`是下一个线程对应的`TR`；

 `TSS`包含CPU所有寄存器的状态信息（就像拍了一个快照一样）；

 `TSS描述符`是指向`TSS`段的指针。

 `TR`用于找到`TSS段`

==switch_to完成的工作==

- 记录切换前的信息
  在`ljmp`指令（长跳转，会传输64位的数据量信息）之前，先将当前CPU的所有寄存器中的值存放到当前TR所指向的段中，从而将切换前的线程的所有信息记录下来。

- 将新的线程信息覆盖给CPU
  然后，让TSS指向GDT表中新的TSS描述符，从而得到指向新的TSS段的指针，将`TSS(n)`置给TR，TR会作为选择子而指向新的TSS描述符，从而指向新的TSS段。

缺点： 使用TSS（Task Structe Segment任务结构段）进行切换执行起来慢，用一条指令做的不能进行指令流水。因此，我们需要从基于TSS的切换而变到Kernel Stack切换。

![image-20240102195733757](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102195733757.png)

![image-20240102195744262](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102195744262.png)

> TSS其实是TCB的一个子段
>

### 进程的创建

linux0.11里面没有线程的概念，但进程和线程在实现上的区别主要在于是否变动**映射表**，而其余创建等操作是相同类似的，因此这里通过讲解**创建进程**`copy_process`来解释**创建线程**

![image-20240102200423995](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102200423995.png)

`fork()`继续往下走，就到了`call _copy_process`语句，父进程复制自己而创建出一个和自己**基本一样的子进程**。而这个函数的**参数就是之前压入栈中的线程信息**

`int copy_process()`中的参数都从内核栈取得，可以看到其中的参数和图中栈的参数一一对应，ps：前边的参数在栈顶，后边的参数在栈底

栈中的ret值，即传入参数eip的值，指向`INT 0x80`的下一句

> 父进程进入fork的时候，在内核栈压入了一些参数，描述了父进程在用户态运行的样子

![image-20240102201037043](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102201037043.png)

`get_free_page()`：找到`mem_map=0`的那一页并且把这个地址返回，再对其进行强制类型转换，将其地址交给指针p。

此时这个块也是内核栈的地址，也就相当于此语句不仅申请了PCB的内存空间，还创建了内核栈的地址空间，这块地址用来做PCB。（0.11中实际起作用的是TSS，所以下边的初始化都是针对TSS的）

`esp0`和`ss0`是内核栈。p所指向的是PCB的初始地址，然后再加上4K（PAGE_SIZE）一页的大小，赋值给`esp0`，指向内核栈的栈顶。将内核数据段`0x10`赋值给`ss0`。

`ss`和`esp`是用户栈。使用父进程的`ss`和`esp`作为用户栈，和父进程共用栈

> 因为当前使用tss做切换，实际上可以不用填写两个stack 

![image-20240102201623069](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102201623069.png)

将`eip`置给**TSS**中，也就是当前父进程的**IP**位置，即执行`fork()`语句的下一句话的地址。

其中让`eax`置为0，是为了让`if(!fork())`语句生效，从而让子进程执行这里面的程序，==实现父子进程分离==。

之后，ldt部分的代码是内存方面的

> `eax=0`执行子进程，`eax!= 0`执行父进程

![image-20240102201654448](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102201654448.png)

子进程上来执行`mov res,%eax`，将`eax`, 即0，赋给`res`，父亲进程的`eax≠0`

父子返回之后和子进程上来都是执行`mov res ,%eax`

`if(!fork()){}`， 对父进程来说，if中的判断语句是false，所以不执行if判断中的语句。子进程相反 

![image-20240102201738962](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102201738962.png)

子进程用了父进程创建的壳子，然后在这个壳子里执行自己的程序。

![image-20240102201753797](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102201753797.png)

子进程在执行exec语句之前，父进程和子进程用的是同样的代码。而子进程一旦进入`if(!fork())`中执行`exec`后，子进程在未来从内核态退回到用户态时（中断返回时），子进程就会执行新的代码（`ls`这个程序的`entry`代码，即`ls`的第一句代码 ），不和父进程执行相同的代码了。

其中中断返回时，实际上执行的是`iret`指令，而该指令即就是找到存放`ss、sp、EFLAGS、cs、ip`的栈，然后把栈里面存的`ip`置给真正的寄存器`eip`。当`pc`在执行时，就会按照寄存器`eip`里的值进行执行。

因此，为了能让子进程切换到用户态时执行**新的代码**， 只需要修改栈中的`ip`值，从而改变`pc`的执行位置即可。

```assembly
lea EIP(%esp), %eax
pushl %eax
```

> [lea指令是Load Effective Address的缩写，意为加载有效地址。它的作用是将一个内存地址的偏移量（即有效地址）传送到一个寄存器中](https://blog.csdn.net/qq_34432960/article/details/108101247)

`EIP`是偏移，`%esp`是当前栈指针。此句话的意思是`EIP + %esp` 置给 `%eax`，即`0x1C`=28，`%esp`加上28以后正好就在`ret`这个地方，而这个地方对应着`eip`的地址。然后，再将`eax`压栈。当执行中断返回时，`pc`就会按照新的`eip`中的值继续执行，从而跳到新的代码中去。

> 注意这里压栈的是EIP的地址，该地址对应的值是iret之后将要执行的程序的地址

![image-20240102202133689](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102202133689.png)

获取`eip`的地址，然后在`do_execve()`中将`entry`（**ls**这个可执行文件的**入口地址**）置给`eip`。将`sp`置给`eip[3]`。从而让进程从内核态退回到用户态时，**PC**指针会跳到与父进程不同代码的地方进行执行，同时也会拥有自己的栈。

目标执行的代码是`ls`读文件命令

### 总结

![image-20240102202211622](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240102202211622.png)

一套流程总结：从**用户栈**到**内核栈**，内核栈再找到**TCB**，使用`switch_to`完成TCB的切换，从而完成**内核栈之间的切换**，最后用`iret`完成**从内核栈到用户栈的切换**

> 将上述流程串起来，参考[操作系统之树](https://www.bilibili.com/video/BV19r4y1b7Aw?p=13)

## CPU调度策略

如何调度算法？

- 使得客户满意
- 使得进程满意
  - 尽快结束任务：==周转时间==（从任务开始到结束）短
  - 用户操作尽快相应：==响应时间==（从操作发生到相应）短
  - 系统内耗时间少：吞吐量（完成的任务量）
- 总原则：系统专注任务执行，又能合理调配任务，但对于不同的设备，调度的策略也会有所不同

![image-20240104195743877](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104195743877.png)

 IO约束型任务：CPU计算任务很少，大部分时间都是IO设备在运行

CPU约束型任务：CPU运算任务较多

> 这两种任务应该IO约束型任务的优先级应该高点，这种任务一般是前台任务，和用户交互，这种任务的优先级也应该高

### FCFS（先来先服务）

![image-20240104200223197](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104200223197.png)

谁先来服务谁，十分的简单，但对短作业来说，执行时间很短，但是等待时间很长。

下图中将P2，P3的位置互换，短作业被提前，平均周转时间`(10+13+42+49+61)/5`平均周转时间变短

基于这种思想，设计出下面的调度算法

### SJF（短作业优先）

shortest job first,SJF

![image-20240104200604044](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104200604044.png)

图右侧的证明表示，一直将短作业提前，所获得的平均周转时间是最短的（这种情况仅针对所有任务几乎是0时刻同时到达，但是实际情况中通常没有这种情况）

同时这种调度又产生一些问题，P2到达时间很早，但是执行P2的时候很晚，其响应时间较长，延申出时间片轮转算法。

实际环境中可以工作的是==最短剩余时间优先调度(shortest remaining time first, SRTF)算法==。每次新任务到达时，选择当前剩余执行时间最短的那个任务调度执行。

> SRTF是可抢占式调度。
>
> 可抢占调度：即不是由于任务自身主动让出 CPU才引起的调度， 也就是说并不是发生诸如当前任务结束、当前任务阻塞时间而引起的调度。只要有新任务出现， 就有可能出现这个任务抢占当前任务的 CPU,所以才被称为可抢占式调度。

### RR（时间片轮转）

round-robin,RR

![image-20240104201016174](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104201016174.png)

对于一个任务来说，其最长的响应时间是$时间片长度 * 到下次抢占时间片之间的作业数$

> 要控制作业数不能太多，时间片的长度也应该精心设计

上面的各种算法都从一个方面考虑，如何同时从两个方面考虑

### 多级反馈队列调度算法

multilevel feedback queue scheduling

![image-20240104201847177](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104201847177.png)

前台任务和后台任务之间的调度就需要引入优先级调度，前台的任务＞后台任务的优先级

但这种情况会引发饥饿，一直有前台任务的情况下，后台任务一直得不到执行

后台任务优先级动态提升，但后台任务（SJF调度）一旦执行，前台的响应时间就会受到影响

如果前后台任务都用时间片，退化为RR，后台任务的SJF如何体现？前台任务如何照顾

上图中的算法没有考虑反馈，实际上是==多级队列调度(multilevel queue scheduling)策略==

![image-20240104202324939](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104202324939.png)

动态调整是多级反馈队列调度的核心

- 按照I/O动态调整

  - 近似解决前台任务识别的问题
  - 如果一个进程最近执行了I/O操作，按照局部性原理，接下来也可能发现I/O，所以识别为前台任务，放在高优先级队列中
  - 通过记录阻塞态来识别是否发生了I/O

- 按照执行时长动态调整

  - 如果一个任务在执行完一个 时间片以后仍然要继续执行，说明该任务最近没有发生I/O操作，也没有执行完成
  - “没发生I/O 操作”可以近似认定这个任务是一个非交互任务，“没执行完成”可以近似认定这个是一个长作 业，此时就将这个任务的优先级降低
  - 首先给所有任务一个较短的时间片执行，没有完成的说明 其任务长度比较长，降低优先级并加长时间片。这些较长的任务还会再轮转，如果任务仍然没有完成，就可以断定这些任务的剩余执行时间就更长了(局部性原理),进一步降低其优先级，并进一 步加长分配的时间片，这样的过程一直继续。

  > 这样的动态调整策略近似实现了最短剩余时间优先调度，而且不需要对任务未来要执行的任务时长进行预测，正好解决了在SRTF 调度中出 现的任务时长预测问题。

![image-20240117102051617](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117102051617.png)

## 一个实际的Schedule函数（多级反馈队列调度算法）

![image-20240104203740224](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104203740224.png)

`TASK_RUNNING`是就绪状态

counter是优先级也是时间片

时钟中断(在该计算机系统中对应0x20号中断)的处理函数被初始化为 `set_intr_gate(0x20,&timer_interrupt)`，每次时钟中断，都会将当前任务的counter的值减1

![image-20240104203648078](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104203648078.png)

![image-20240104203839870](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104203839870.png)

 阻塞进程的counter不等于0的时候退出执行，而非阻塞进程是counter=0之后停止执行，所以对counter进行重新赋值动态调整优先级的时候，阻塞的进程优先级会高

![image-20240104204222730](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104204222730.png)

图中的$c(\infty)≤2p$ （根据无穷级数计算），$C(t)$表示第t次调整时的counter

轮转调度，近似SJF调度，因为短作业一定会比长作业先完成

CPU调度：一个简单的算法折中了大多数任务的需求

## 进程同步与信号量

![image-20240104211132618](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104211132618.png)

上边的方案，如果有两个生产者进程，就不能够正常工作了

> 如果在counter!=0的时候唤醒消费者，在counter!=BUFFER_SIZE的时候唤醒生产者，能否解决P2不能被唤醒的情况
>
> 存在没有线程睡眠但是疯狂唤醒的情况，浪费系统资源？

![image-20240104214630963](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104214630963.png)

![image-20240104214538065](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240104214538065.png)

-1表示有一个进程正在睡眠，-2表示两个 

一个例子：一种资源的数量是8，对应的信号量是2，表示**有两个资源可以使用**，如果对应的信号量是-2，表示，有两个进程等待使用这个资源

![image-20240110205623923](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240110205623923.png)

```c++
V(semaphore s){
	s.value++;
	if(s.value <= 0){
		weakup(s.queue);
	}
}
```

![image-20240110210125051](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240110210125051.png)

`mutex`：互斥信号量，仅允许一个线程对缓冲区进行修改

## 信号量临界区保护

![image-20240110211822675](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240110211822675.png)

### 软件方法

#### 轮换法

![image-20240110212057395](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240110212057395.png)

缺陷：P0结束调度之后，如果再次抢占时间片，尽管此时临界区没有别的进程使用个，但是由于turn=1，P0不能进入，违背有空让进

#### 标记法

![image-20240110212634105](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240110212634105.png)

这种对称标记会导致无限等待

#### Peterson算法

![image-20240111104524890](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111104524890.png)

以P0为	例子，在用`flag[0]= true`表示想用，然后用`turn = 1`“谦让”

![image-20240111104823353](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111104823353.png)

只能针对两个进程

#### Lamport面包店算法

![image-20240111105134867](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111105134867.png)

`choosinog[i]`控制只能有一个进程正在选号

![image-20240111105245906](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111105245906.png)

(a,b)<(c,d)意味着 a<c或 a==c 且 b<d

缺陷：取号的时候还会溢出的问题，因为号一直在累加

上边的方法都是在软件层次中设计

### 硬件方法

#### 关中断

![image-20240111105715945](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111105715945.png)

 `cli()`是关中断指令

但是上述方法在多CPU（多核）时候并不好用，关中断只能控制单个CPU

> 开/关中断的确是保护临界区的简单而有效的方法，但该方法也存在一个很大的缺陷，即只能 工作在单 CPU计算机系统下。
>
> 关中断指令`cli()`的工作原理是执行这条指令的 CPU 会将其 CPU标志寄存器(即 EFLAGS 寄存器)中的中断允许标志位IF(interrupt fag)设置为 0,一旦这 个位设置为0,这个 CPU就不会在每次执行完指令时检查并处理中断了。
>
> 但是，对于一个多CPU 计算机(多核或多处理器)系统，这个关中断操作对其他CPU 没有影响，其他CPU照样可以执行任何任务，当然完全可以执行另一个要进入临界区的进程并让其进入临界区。

#### 硬件原子指令法

![image-20240111111120084](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111111120084.png)

![image-20240111111142998](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111111142998.png)

硬件原子指令代码块中的部分是一个整体，要么不执行，要么全部执行

如果当前lock为true，返回true，等待

如果当前lock为false，返回false，但将lock置为true，进入临界区

- 有空让进：如果临界区有空，lock 就是 false,一定会至少有一个进程的 TestAndSet 会返回 false,进入 临界区，满足有空让进

- 有限等待：while循环过程中，一旦有其他进程开锁且抢到时间片则进入临界区执行

- 互斥进入：指向的lock是共享的，且是原子操作（执行 TestAndSet 指令时，CPU 会锁住内存总线，禁止其他 CPU在该指令结束之前访问内存），满足互斥进入

## 信号量的代码实现

![image-20240117150730721](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117150730721.png)

![image-20240111132657654](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111132657654.png)

![image-20240117150935098](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117150935098.png)

![image-20240117151011711](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117151011711.png)

上边的信号量有正有负

新资源到来会使信号量+1，如果阻塞队列不为空，那么将唤醒一个进程，该唤醒哪一个？

直观来看是第一个，但是后边进程优先级更高怎么办？

可以在进队列的时候对优先级进行处理，需要一个复杂的调度算法。

实际上，sem-post 决定要唤醒队列上的哪个进程时，更好的解决办法是唤醒阻塞在信号量上的所有进程，然后由 CPU调度算法 schedule()来决定让哪个进程获得这个信号量。进程再次对自己的信号量进行检查，如果获得了就继续执行，没有获得继续阻塞（`while`的妙用，`schedule()`之后又轮到自己执行之后应该检查一下自己有没有信号量，所以这里是`while`）

![image-20240117151646142](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117151646142.png)

每次都是唤醒阻塞的所有，负信号量（记录阻塞数量）就没用了，所以只有正数

![image-20240117154230159](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117154230159.png)	

![image-20240111133802879](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111133802879.png)

![image-20240111133748166](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111133748166.png)

![image-20240111134103548](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111134103548.png)

将阻塞队列中所有的进程都唤醒，由`schedule()`根据优先级判断哪个进程执行

使用while的方法，不需要记录负数信号量，因为每次都是全部唤醒，没必要记录有几个在等待

> 配套实验5

## 死锁处理

![image-20240111135215525](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111135215525.png)

将`P（empty）和P（mutex）`顺序互换，将`P(full)和P(mutex)`顺序互换

先执行`P(mutex)，mutex 1->0;P(empty) 0->-1`此时切换到消费者，`P(mutex) empty 0->-1`产生阻塞

==死锁的4个必要条件==：

1. 互斥使用
2. 不可抢占
3. 请求和保持：进程必须占有资源，再去申请别的资源
4. 循环等待

==死锁处理方法==：

1. 死锁预防：破坏死锁的条件

2. 死锁避免：检测每个资源请求，如果造成死锁拒绝

3. 死锁检测+恢复：检测到死锁出现时，让一些进程回滚，让出资源

4. 死锁忽略：不去处理死锁，对于个人PC之类，可以直接重启了（Windows、Linux 等，采用的就是这种“什么也不做”的死锁忽略处理方法）

### 死锁预防

 ![image-20240111140228285](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111140228285.png)

### 死锁避免

![image-20240111140705554](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111140705554.png)

![image-20240111140716272](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111140716272.png)

每次从头到尾不停检测，如果有能结束的进程，就将该进程结束并可用资源加上该进程占用的资源

如果找不到没结束的进程，或者资源不够，则进入end进行判断，存在未结束进程则说明可能有死锁

复杂度：$T(n)=O(mn^{2})$，m是资源个数，n是进程个数，可见代价十分大，每次申请，都必须判断

银行家算法还需要已知进程执行完成所需的资源总数，这并不是一个容易获得的信息

### 死锁检测和恢复

![image-20240111141243590](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111141243590.png)

上边的方法则是发现问题再处理

`deadlock+{i}`表示了造成了死锁的进程集合

面临了许多问题：

1. 如何实现回滚，将执行指针PC往前调整比较容易，但一个进程对系统做出的修改，如已经修改的文件、发出的网络数据包应该怎么办?
2. 回滚到哪里更加合适，应该是回滚到能刚好解除死锁的地方最好，但如何找到这个地方呢?
3. 选择哪些进程进行回滚? 选择优先级低的进程可能对死锁解除的效果并不好

# :three:内存管理

## 内存使用和分段

![image-20240111150731734](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111150731734.png)

- 编译时重定位
  - 只能放在固定位置（只有那些执行固定任务的计算机系统才能在编译时就预先已知将来的执行位置，例如卫星上工作的计算任务通常都是在地面上就已经固定好的。）
  - 效率高
- 载入时重定位
  - 较为灵活
  - 载入内存就不能动，不方便进程的换入/换出

- 实际上最具有实用价值的是运行时重定位

每个进程各自的基址放入PCB中，执行指令第一步先从PCB中取出这个基址，放入基址寄存器中，<font color = red >每执行一条指令，都先将指令中的逻辑地址加上基址以后才放在地址总线上</font>。

每条指令都需要这样的地址计算，为了提高指令执行效率，可设计硬件来快速完成这个地址计算过程，这个硬件就是著名的存储管理部件(MMU)。

![image-20240111153416043](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111153416043.png)

![image-20240111153753670](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111153753670.png)

GDT表针对整个系统来说，LDT是每个进程的，L中的L是Local，它们相当于都是段表

GDT 表描述的是操作系统的代码段、数据段等，LDT 表才用来描述每个进程的代码段、数据段等。

GDT 表还指向各个进程的 LDT 表项

![image-20240117195402682](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117195402682.png)

操作系统统启动时将操作系统代码载入到内存中， 系统启动以后通过 `shell` 创建出进程1和进程2。现在物理内存中存放着操作系统、进程1和进 程 2,假定操作系统、进程1和进程2都要执行指令`call 40`。

具体见书p160

![image-20240117203604247](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117203604247.png)

![image-20240117203620367](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117203620367.png)

![image-20240117203630292](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240117203630292.png)

## 内存分区和分页

如何分割内存来放前边提到的程序各个段

### 分区

![image-20240111160909217](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111160909217.png)

左侧展示了固定分区，右侧展示可变分区

![image-20240111161037237](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111161037237.png)

关于可变分区，有几个问题需要处理

如果有内存请求，有多个空闲分区可以满足

- 最佳适配：选择大小和内存请求接近的（满足要求，但不浪费的最小块），会产生很多不可用的小碎片
- 最差适配：选大的（满足要求，最大），差适配会导致出现很多中等大小的空闲内存区域。
- 最先适配：选择空闲表满足提条件的第一个，比较简单，速度快

> 疑问：分区是对虚拟内存的管理，如何理解？
>
> 分区引出分页，分页和内存的换入和换出密切相关

### 分页

解决了分区的内存效率问题

![image-20240111162337618](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111162337618.png)

内存紧缩的过程中，上层用户程序不被执行，因为整理内存的过程中，要修改LDT表，程序的重定位基址会发生变化

![image-20240111163817575](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111163817575.png)

将段放进分为固定大小的页

> MMU：内存管理单元

![image-20240111165448328](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111165448328.png)

在linux0.11中，页表在CR寄存器中存放

上述过程中将逻辑地址`0x2240`转换为了物理地址`0x3240`，注意该地址是寻址的地址，和页表项的大小无关

32位程序中， 最大的逻辑地址是2^32^，每个页面的大小为4K(2^12^)，共有2^20^个（1M）页表项

一个页表项信息是通常用4B（32位）表示

## 多级页表和快表

为了提高内存空间利用率，页应该小，但是页小，页表就会大

![image-20240111193625071](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111193625071.png)

图中应该是4MB内存（每个进程都要维护自己的页表，都需要这么多）

实际上大部分逻辑地址根本不会用到，可以用到的逻辑页才有页表项，但是由于逻辑页号不连续，对查询造成问题，不能像之前连续页号的时候快速定位，二分查找，复杂度$O（logT）$T表示页表项数量

多级页表解决上述问题

![image-20240111203221473](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111203221473.png)

每个页目录包含2^10^个页表项，一共有2^10^个目录项

图中仅3部分内存被使用，读入三部分对应的页表，加上页目录占用的内存，总共占用16KB，原小于之前的4MB

> 每个页目录使用4个字节寻址，前10位表示页目录号，紧随的10位表示页号，最后12位表示页中的偏移

虽然提高的空间效率，而且在时间上优于逻辑页不连续的情况，但是时间方面仍然有优化的空间。

因为每多访问一级页表，就会在时间上多开销。

采用快表来缓解这个问题

可以借助硬件电路设计来实现一次完成整个缓存页表的查找，这就是著名的**变换旁查缓冲器** (translation lookaside buffer,TLB,也称地址转换后援缓冲器)，我们常称之为“快表”。

![image-20240111203856208](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111203856208.png)

最后，可以这样==总结分页机制==

1. 将物理内存分成页并以页为单位进行内存分配，可以解决内存碎片问题造成的空间浪费
2. 一旦分页以后，需要存放页表来完成地址转换过程
3. 采用多级页表可以降低存放页表造成的空间开销
4. 采用快表来降低多级页表造成的时间开销
5. 最终形成的是综合多级页表和快表的分页机制，时间开销和空间开销上都表现良好，很多实际操作系统都支持快表和多级页表

![image-20240111204748913](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240111204748913.png)

## 段页结合的实际内存管理

![image-20240112141849646](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112141849646.png)

![image-20240112142556165](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112142556165.png)

首先将逻辑地址转换为虚拟地址，再根据虚拟地址，通过查询页表的方式获得物理地址，详细过程见书籍p171（段、页结合时进程对内存的使用）

### 实际实现

核心功能：

- 在虚拟内存中分段
- 建立段表
- 将虚存页映射到空闲物理页框
- 建立页表。

![image-20240112143758839](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112143758839.png)

设置了段表的基址，对虚拟内存完成了分割

`new_data_base=nr*0x4000000`完成了虚拟内存的分割，下边跟着的两句完成了段表的建立

nr是进程号，p指代的pcb

![image-20240112154225853](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112154225853.png)

一种简单的分割方案，互不重叠进行了简化，可以用一套页表

代码段和数据段地址是相同的一块

> 段不重叠，查询页表不会造成歧义，不需要切换页表

==之后进行分页，建立页表==

系统初始化函数`mem_init` 中已经填好的 `mem.map `数组。

![image-20231228203136062](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231228203136062.png)

![image-20240123161753888](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123161753888.png)

根据函数名称 `copy-page.tables(old.data.base,new.data.base,data limit)` 不难想到，其功能是 将父进程的虚存空间(语句`old_data_base=get_base(current->ldt[2]`)用来得到父进程的虚存空 间)和内存页框的映射关系复制给子进程的虚存空间 new.data base。

==较复杂，看书籍p173==一个真实的段页式内存机制

![image-20240112160238649](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112160238649.png)

## 内存换入-请求调入

![image-20240112161106975](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112161106975.png)

缺页之后产生中断，系统请求调页

请求掉段：发现访问的段不在内存中，直接将一段都换入 

![image-20240112162435358](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240112162435358.png)

具体实现见书籍p189

## 内存换出

![image-20240115145331895](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115145331895.png)

### FIFO

![image-20240115145815440](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115145815440.png)

不太合理，从图中看D引发的缺页，使得A被换出，但是之后A马上又要用到了，又缺页，又把A换入

### MIN

![image-20240115150049849](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115150049849.png)

每次往后看谁最近不会被使用，将其换出，但是没发知道未来的事情

### LRU（Least Recently Used）

![image-20240115150618695](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115150618695.png)

> 还有一种算法是LFU算法，力扣上有实现LRU和LFU的题

![image-20240115150809787](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115150809787.png)

上述做法在实际运用中每次都要修改时间戳，需维护一个全局时钟，还要找到最小值，代价较大

 ![image-20240115151432280](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115151432280.png)

### LRU近似实现

![image-20240115151757542](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115151757542.png)

如果某页被访问了，将R置1

SCR算法也称Clock Algorithm

![image-20240115152558463](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115152558463.png)

#### 存在问题

![image-20240115153015410](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115153015410.png)

分配的页框个数，应该覆盖程序中常用的局部（采用工作集的算法进行计算分配） ，也可以先设定一定的值，当发现缺页严重的时候再加大页框数量

![image-20240123194407462](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123194407462.png)

解决页框分配的策略：

- 局部考虑：计算出进程当前覆盖的局部是多大，分配的页框大于局部。如果空闲内存不足，将他挂起，将新获得的页面分配给需要的进程
  - 缺点：很难去估计局部覆盖量
- 全局置换策略：如果某个进程需要物 理页框时，操作系统会去一个全局空闲物理页框链表中取出一个空闲物理页框进行分配，同时操作系统会定期地对分配给所有进程的所有页面进行 clock 算法扫描，发现最近一段时间内没有被访问的页面，就将其换出到磁盘上，并将对应的物理页框释放到空闲页框链表中。
  - 缺点：一个局部大的进程将会获得更多的资源，甚至可以通过代码的设计抢占资源

![image-20240115153619156](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115153619156.png)

# :four:设备驱动

操作系统将外设抽象为文件，程序员通过文件接口open,read,write来使用

![image-20240123195654238](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123195654238.png)

![image-20240123195704514](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123195704514.png)

## I/O与显示器

![image-20240115155921078](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115155921078.png)

![image-20240115160524778](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115160524778.png)

![image-20240115160721041](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115160721041.png)

![image-20240115161042928](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115161042928.png)

![image-20240115161305203](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115161305203.png)

![image-20240115161437867](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115161437867.png)

`q`是输出队列，如果队列满了，`sleep`

![image-20240115161833775](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115161833775.png)

![image-20240115161928280](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115161928280.png)

`ah`中放属性，`al`中放字符

![image-20240115162436144](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115162436144.png)

![image-20240115162456352](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115162456352.png)

![image-20240115162531581](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115162531581.png)

## 键盘

![image-20240115163516624](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115163516624.png)

![image-20240115163708833](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115163708833.png)

![image-20240115163851239](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115163851239.png)

![image-20240115164130280](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115164130280.png)

![image-20240115164556018](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115164556018.png)

![image-20240115164841361](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240115164841361.png)

## 生磁盘的使用

![image-20240116142654967](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116142654967.png)

> DMA，Direct Memory Access，即直接存储器访问，计组中有

![image-20240116143145536](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116143145536.png)

这样用对程序员来说太繁琐，需要理解柱面，磁头等细节

![image-20240116145054915](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116145054915.png)

![image-20240116145126750](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116145126750.png)

![image-20240123205823895](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123205823895.png)

可以将几个扇区联合视作一个盘块，空间利用率下降了，但是读写速度提升了，空间换时间。

> 时间缩短是因为，寻道一次，可以一下读写的空间大了
>
> 但是整体变大，容易有碎片，所以空间利用率低

![image-20240123224805166](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240123224805166.png)

![image-20240116145538879](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116145538879.png)

linux0.11的盘块为两个扇区，可以由`b_blcoknr<<1`看出

![image-20240116145913664](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116145913664.png)

### 磁盘调度算法

#### FCFS磁盘调度算法

先来先服务

![image-20240116150336951](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116150336951.png)

#### SSTF磁盘调度算法

先访问寻道距离近的

![image-20240116150552077](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116150552077.png)

读写频繁的时候大部分都在中间附近，距离远的两端可能会有饥饿问题

#### SCAN磁盘调度

![image-20240116150815070](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116150815070.png)

缺点：中间的还是比两边的更容易被处理

#### C-SCAN磁盘调度（电梯算法）

![image-20240116151018765](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116151018765.png)

电梯算法的实现

![image-20240116152137065](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116152137065.png)

### 生磁盘使用流程

![image-20240116152002300](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116152002300.png)

得到盘块号和文件系统相关

实际的`make_req`过程还和内存中的缓存有关（书中有相关部分，待看）

在磁盘控制器已经处理完成一个磁盘请求时，会产生磁盘中断。磁盘中断处理函数 `read(write)_intr`会首先执行 `end_request`,在其中会唤醒一个进程，该进程就是正在等待那个磁盘请求的进程。

## 从生磁盘到文件

核心主题：如何从文件得到盘块号

讲文件的字符流映射到盘块

### 映射结构

#### 顺序结构

![image-20240116161542296](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116161542296.png)

优点：访问任何字符流位置都可以根据公式快速计算出对应的磁盘快号（类似数组）

缺点：如果要对文件进行改写，比如要在文件的某个中间位置添加一些字符。为保证添加以后的字符流在磁盘上仍连续存放，需要将这个中间位置以后的磁盘块内容全部往后挪动，非常费时。

####  链式结构

![image-20240116162327881](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116162327881.png)

每个磁盘块中存放下一块的实际位置

动态方便，但是索引不方便，要读入第三块，必须读入前两块

#### 索引结构

![image-20240116162435344](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116162435344.png)

#### 多级索引

![image-20240116162933153](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116162933153.png)

多级索引的工作效果

- (1)首先是索引存储结构，所 以能较好地支持文件读操作和写操作。
- (2)如果文件比较小，比如小于6个盘块，可以利用 inode (在读写文件时这个数据结构通常是已经读入到内存中)中存储的直接数据块信息找到逻辑盘块 对应的物理盘块号，读写速度很快。
- (3)对于中等大小的文件，只要读入一阶索引块以后就能映射出物理盘块号，速度也不慢。
- (4)通过多阶间接索引，可以映射尺寸很大的文件。而且即使文件尺寸很大，索引的阶数也不会很大，这是因为文件尺寸和索引阶数是一个指数关系，所以对于很大尺 寸的文件存取也不太慢。

## 文件使用磁盘的实现  

见书籍。相关：实验8

## 目录与文件系统

文件系统用来抽象整个磁盘

![image-20240116205140392](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116205140392.png)

![image-20240116205623727](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116205623727.png)

如何根据`/my/data/a`得到文件a的FCB

可以存放目录下所有文件的FCB和对应的路径名，但是这样对于查询不利，每次查询的时候，顺序取出了路径名也取出了FCB，但是FCB仅在确实匹配的情况下被需要。

所以目录中可以不放FCB，只放相应的地址，如下图，根据索引找到下一级目录的FCB

![image-20240116211117076](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116211117076.png)

![image-20240116212313068](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116212313068.png)

inode位图描述FCB数组的使用，数据盘块位图描述物理盘块的使用情况

![image-20240116212237179](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116212237179.png)

## 目录解析代码实现

见书籍p239

![image-20240116224719891](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116224719891.png)

`current->root`是根目录

![image-20240116225437275](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116225437275.png)

![image-20240116225550514](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240116225550514.png)

