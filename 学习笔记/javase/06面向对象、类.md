[toc]
<font size=3>
# 面向对象

## 面向对象和面向过程的区别
- c语言**完全面向过程**
- c++**一半面向过程，一半面向对象**
- java**完全面向对象**

### 面向过程
- **缺点**：耦合性强，难以扩展
- **优点**：小型项目（功能）采用面向过程开发效率较高

### 面向对象
- **优点**：耦合性低，扩展力强
- OOA（Object-Oriented Analysis）：面向对象分析
- OOD（Object-Oriented Design）：面向对象设计
- OOP（Object-Oriented Programming）：面向对象编程
>成为主流的原因：更符合人类思维

## 面向对象的三大特征
- 有了封装，才有继承，有了继承，才能说多态

### 封装

#### 封装的作用
1. 保证内部结构的安全
2. 屏蔽复杂，暴露简单

#### 如何封装
1. 私有化属性（private：修饰之后该变量只能在该类中访问）
2. 对外提供简单的访问入口

### 继承

- 用“is a”来描述的都可以使用**继承** Cat is a animal
- 用“has a”描述的都以**属性的形式**存在 I have a pen

#### 继承的基本作用和主要作用
- 基本：子类继承父类， 代码可以得到复用
- 主要：有了继承，才有方法覆盖和多态机制

#### 继承的相关特性
- B类继承A类，则称A类为超类、父类、基类 &emsp; B类称为子类、派生类、扩展类<br>class A{ } <br>class B extends A{ }
>superclass 父类 subclass 子类
- **只支持单继承**，不像c++一样支持多继承
> class A extends B, C{ }是错误的
- 虽然不支持多继承，但是有的时候会产生间接继承的效果
> class C extends B，class B extends A 也就是说C直接继承B，间接继承A
- 子类继承父类的时候，除了构造方法不能继承之外，剩下都可以继承。但是**私有属性不能在子类中直接使用**
- java中没有显示继承任何类，则默认继承Object，Object类是java语言提供的根类
- **继承的缺点**：父类修改，子类受牵连，耦合度高

### 多态

多种形态，多种状态，编译和运行有两个不同的状态<br>编译期叫**静态绑定**<br>运行期叫**动态绑定**<br>

```java
Animal a = new cat()
a.move()
```

- 静态绑定：编译的时候编译器发现a的类型是Animal，所以编译器会去Animal类中找move（）方法。找到了，绑定编译通过。
- 动态绑定：但是运行的时候和底层**堆内存**当中的实际对象有关。**真正执行的时候**会自动调用“堆内存中真实对象”的相关方法

#### 方法覆盖
子类继承父类之后一些“行为”可能无法满足业务需求，需要改进，需要**方法覆盖**（对该方法进行重新编写，又叫方法重写Override/Overwrite）
- 有final或者private修饰的方法都不能

- 在代码级别上构成方法覆盖的条件：
    - 两个类必须有继承关系
    
    - 重写后的方法必须和之前的方法具有**相同的返回值类型**（对基本数据类型来说必须相同，引用数据类型返回类型可以变为该类的子类，意义不大，开发中不需要），**相同的形式参数列表**，**相同的方法名**
    
    - 访问权限**不能更低**，可以**更高**(子类方法不能低于超类方法的可见性)
    
      > 继承必须确保超类所拥有的性质在子类中仍然成立
      >
      > 一个例子
      >
      > ```
      > SuperClass obj = new ChildClass()
      > ```
    
    - 重写之后的方法不能比之前的方法抛出更多的异常，可以更少
> 访问权限public比protected高
> - 方法覆盖只是只是针对于方法，和属性无关
> - 私有方法无法覆盖
> - 构造方法不能被继承，所以也不能被覆盖
> - 方法覆盖只是针对于实例方法，静态方法覆盖没有意义
>   - 方法覆盖通常和多态联系起来    
>
> ---
>
> 对于重载：
>
> - **方法名相同**
> - **参数列表**不同
> - 与返回值类型和修饰符无关

#### 多态的基础语法
- 向上转型：**父类型的引用**允许指向**子类型的对象** 子类---->父类（自动类型转换）
- 向下转型：父类---->子类（强制类型转换，需要加强制类型转换符），向下转型是为了调用子类特有的方法
> - 这里的**自动类型转换和强制类型转换**都是**非专业说法**，实际在引用类型转换中不存在该说法，强制类型转换与自动类型转换仅存在于基本数据类型中
> - 无论是向上转型还是向下转型，两种类型之间**必须有继承关系**
> - 如果访问的方法是**子类对象中特有的方法**，必须进行**向下转型**
> - **向下转型的风险**：ClassCastException：类型转换异常
> > 向下转型风险的规避方法：（凡是向下转型都要用instanceof）<br>
> > instancof
> >
> > - instanceof可以在运行的动态阶段判断引用指向的对象的类型
> > - instanceof语法：**（引用 instanceof 类型）**
> > - instanceof运算符的结果只能是：true/false
> > - （c instanceof Cat）为true：c引用指向的堆内存中的对象是一个Cat

#### 多态在实际开发中的作用
- 降低程序的耦合度，提高程序的扩展力

## 类和对象的概念

### 类
- 类是现实世界中不存在的，是一个抽象的概念。是一个模板，是我们大脑进行**思考、总结、抽象**的一个结果
- 类中描述的是所有**对象**的“共同特征信息”
>明星是一个类

#### 类的定义

```java
[修饰符列表] class 类名{
    类体 = 属性（变量形式存在） + 方法
}
```

#### 抽象类
- 抽象类无法实例化，无法创建对象（无法new，但是可以有该类型的变量），用来被子类继承
- 抽象类是：类和类之间有共同特征，将这些具有共同特征的类再进一步抽象形成了抽象类，由于这些类本身是不存在的，所以抽象类无法创建对象
- 抽象类与抽象类之间有共同特征的话，还能再进一步抽象
- 抽象类也是**引用数据类型**

##### 抽象类的定义

```java
[修饰符列表] abstract class 类名{
     类体;
}
```

- 抽象类虽然不能被实例化，但是有构造方法，该构造方法供子类通过super（）使用
- 抽象类关联**抽象方法**，抽象方法表示没有实现的方法（没有方法体的方法）<br>例如：public abstract void doSome（）；
> 抽象方法特点：
> - 没有方法体，以分号结尾
> - 修饰符列表有abstract关键字
- 抽象类中可以没有抽象方法，**抽象方法必须出现在抽象类中**
- <font color=red>非抽象类继承抽象类的抽象方法必须将抽象方法实现（通过方法覆盖）</font>否则编译报错
> 错误：java中没有方法体的方法都是抽象方法
>
>  Object类中很多方法都没有方法体，都是以分号结尾的，但是它们都不是抽象方法，例如：
>
> `public native int hashCode();`
>
> 前边的修饰符没有abstract，但是有native。表示调用JVM本地程序

### 对象（实例）
- 对象是实际存在的个体
>姚明是一个对象，属于**明星**类

<font color=red size=4>**对象是通过类创造出的个体**   通过类创造对象的过程叫==实例化==<br>**抽象**：多个对象具有共同特征，进行思考总结提取共同特征的过程</font>

#### 对象的创建和使用

```java
new 类名();
```

>例如：XueSheng s1 = new XueSheng();

## 局部变量、成员变量、实例变量、静态变量
- 方法体中的声明的变量：**局部变量**
- 方法体外声明的变量：**成员变量**（即“属性”）
- **成员变量**可以分为**实例变量**和**静态变量**
- **实例变量**：对象级别的变量
- **静态变量**：用static修饰的变量

>**成员变量**没有手动赋值时，系统默认赋值（在构造方法执行过程中进行）
> - 局部变量在堆栈区存储
> - 实例变量在堆区
> - 静态变量在方法区

### 实例变量的访问

```java
引用.实例变量名
```

## 实例变量为引用时的内存情况

![image-20231019222820420](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231019222820420.png)

> 字符串实际是在方法区的字符串常量池中

## 编译过程

- 如果编译一个java文件**a**，该文件调用了另一个java文件**b**中的类，则编译器会自动编译**b**

## 构造方法

### 语法结构

```java
[修饰符列表] 构造方法名 (形式参数列表) {
    方法体
}
```

> - **构造方法名字**和**类名**必须一致
> - **不需要返回值类型**
- 是一个比较特殊的方法，用来**创建对象**并且==同时==**给对象的属性赋值** 
- 一个类**没有提供任何构造方法**的时候，系统会默认提供一个无参数的构造方法，该构造方法被称为**缺省构造器**
> - 如果提供了构造方法则系统不再提供无参构造方法
> - 无参数构造方法中虽然没有代码，但是是在这个方法里边进行实例变量默认值初始化
- 采用**new**来调用
- <font color=red> 实例变量是在构造方法执行的过程中完成初始化的</font>
- 在执行子类的构造方法时一连串调用了父类的构造方法，父类的构造方法又调用它父类的构造方法，但是实际上**对象只创建了一个**



</font>