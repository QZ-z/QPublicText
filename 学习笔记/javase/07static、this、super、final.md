[toc]
<font size=3>

# static

- static修饰的都是**类相关的**，**类级别的**
- 所有用static修饰的，都用“**类名**.”的方式访问
- static修饰的变量：**静态变量**（存在于方法体外，成员变量的一种）
> 静态变量在类加载的时初始化，不需要new对象，储存在方法区
- static修饰的方法：**静态方法**
- **成员变量**（在方法体外声明）又可以分为：**实例变量**，**静态变量**
- **工具类**是为了方便编程而开发的类，其中的方法一般是静态的
> 可以用引用去调用静态变量（不会出现空指针异常），但是不支持这样做，因为会影响程序员的判断

## 静态代码块

```java
static{
    java语句;
}
```

- 存储在方法区
- 在类加载时执行，并且只执行一次，在main方法之前执行
- 存在多个的时候，从上而下执行
> **静态代码块**和**静态变量**是有前后顺序的

### 静态代码块的作用
- 静态代码块不常用，不是每个类中都要写
- 静态代码块这种语法机制实际上是sun公司给java程序员的一个特殊的时刻，这个时机叫做：**类加载时刻**

## 实例代码块

```java
{
    java语句;
}
```

- **执行时机**：在构造方法执行前执行前自动执行，可执行多次
-  这种语法机制实际上是sun公司给java程序员的一个特殊的时刻，这个时机叫做：**对象构建时机**

# this

- 是一个关键字，全部小写
- 一个对象一个this
    - this是一个**引用**
    - this保存当前对象的内存地址，指向自身
    - 严格意义上来说，this代表的就是当前对象
    - **this存储**在堆内存中对象的内部
> 大部分情况可以省略

## this的使用
- this能使用在实例方法中，谁调用这个实例方法，this就是谁
> **this代表的是当前的对象**
- this**不能使用在静态方法**中，因为this代表的是当前对象，而静态方法的调用不需要对象

### this在构造方法中的使用
- 通过一个构造方法调用**同一个类**的另一个构造方法

```java
this(实际参数列表)
```

>只能出现在构造方法中的第一行。显然出现多个this（）是不合法的。

## this不能省略的情况
- 区分实例变量和局部变量的时候

# super

super是关键字，全部小写，代表“当前对象”继承的那部分父类型特征
- **this**可以出现在实例方法和构造方法中，不能使用在静态方法中
- **super**可以出现在实例方法和构造方法中，不能使用在静态方法中
- **super不是引用**，super也不保存内存地址，super也不指向任何对象。只是代表当前对象内部的那一块父类型的特征。

## super.
- 不仅能访问变量，还能访问方法

- 大部分情况可以省略

- **不能省略的情况**：如果父类型和子类型有同名属性或方法，想在子类中访问父类的这个属性或方法则必须加**super.**

  > 例如：都有name，实际上两个name名字不同，一个叫this.name，一个叫super.name
  >
  > - 这种同名属性有什么用途？

```java
public class Vip {
    //Vip 默认继承 Object
    //重写从 Object 类中继承过来的 toString()方法
    public String toString(){
    return "我是金牌会员";
}
    public void test(){
        System.out.println(super.toString());
        System.out.println(this.toString());
        System.out.println(toString());
    }
}
public class VipTest {
    public static void main(String[] args) {
	    Vip vip = new Vip();
    	vip.test();
    }
}
```

- 运行结果

![image-20231020110612408](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20231020110612408.png)

## super（）

- 只能出现在构造方法的第一行，通过当前构造方法去调用“**父类**”中的构造方法 <br>目的：创建子类对象的时候，先初始化父类型特征
- **子类的构造方法第一行没有手动写super（）和this（）的时候默认会有一个隐性的super（）来调用父类的无参数构造方法，所以要保证父类无参数构造方法的存在**
- 因为和this（）都是只能出现在构造方法的第一行，所以与其不能共存
- 无论如何，父类的构造方法一定会执行
- super（实参）作用：初始化当前对象的父类型特征。**并不是创建对象**。

# final
- 是一个关键字

- 修饰**变量以及方法，还有类**等

  > 不能修饰构造方法

## final修饰的类
- 无法被继承

## final修饰的方法
- 无法被覆盖

## final修饰的变量
- 修饰的**局部变量**，一旦赋值，就不能被改变（即只能赋值一次）
- 修饰**引用**，也同理，引用实际也是变量，引用不能被再次赋值，但是引用指向的对象可以修改
- 修饰**实例变量**，系统不会默认赋值，必须程序员手动赋值，采用final修饰的实例变量一般添加static修饰，以节省空间
- static final联合修饰的变量称为**常量**，常量名建议全部大写，每个单词之间用下划线分割。
- 常量一般是公开的public
- 和abstract不能**同时出现**，编译会报错
- 会影响 JAVA类的初始化:
  - final 定义的静态常量调用时不会执行 java 的类初始化方法，也就是说不会执行 static 代码块等相关语句，这是由 java 虚拟机规定的
> 实例变量没有手动赋值，系统会默认赋值。实例变量在构造方法执行过程中（new对象的时候）赋值

</font>