[toc]
<font size=3>
# 标识符

## 什么是标识符？

- 凡是程序员自己有权利命名的单词都是标识符

## 命名规则

- 标识符**只能**由**数字，字母（包括中文），下划线_，美元符号$组成**
- 不能以数字开头
- **关键字**不能做标识符
- 标识符严格区分**大小写**
- 理论上**没有长度限制**

> 虽然区分大小写，但是如果出现A类和a类，谁在前生成谁


## 标识符命名规范

- 见到名字知道什么意思
- 遵循**驼峰**命名方式，有利于单词与单词之间进行很好的分割
- **类名和接口名**首字符大写，后边每个单词首字母大写
- **变量名和方法名**首字母小写，后边每个单词首字母大写
- 所有**常量名**全部大写，每个单词之间用下划线分割

# 关键字

## 什么是关键字？

- 在SUN公司开发Java语言的时候，提前定义好了一些具有特殊含义的单词，这些单词全部小写，具有特殊含义，不能用作标识符。

> 所有关键字都是全部小写


# 变量

## 什么是变量？

- 变量就是一个存数据盒子。（盒子大小谁来决定啊？数据类型）
在内存中的最基本的存储单元。
存数据用的，而且这个数据是可变的，所以叫做变量.

## 变量的分类

- 类体中声明的叫成员变量
- 方法体中声明的叫局部变量
- 实例变量：对象级别的变量

## 变量的作用域

- 出了大括号就不认识

# 数据类型

## 基本数据类型

可分为**4大类** **8小种**

- 第一类：整数型 byte short int long
- 第二类：浮点型 float double
- 第三类：布尔型 boolean
- 第四类：字符型 char

| 数据类型 | 中文名 | 字节数 | 取值范围 | 缺省默认值 |
| --- | --- | --- | --- | --- |
| byte | 字节型 | 1 | -128~127 | 0 |
| short | 短整型 | 2 | -32768~32767 | 0 |
| int | 整型 | 4 | -2147483648~2147483647($2.147483647 * 10 ^ 9$) | 0 |
| long | 长整型 | 8 |[-2^63^~2^63^-1] (~9,223,372,036,854,775,807) (数量级是$10^{18}$)  | 0L |
| float | 单精度浮点数 | 4 |  | 0.0f |
| double | 双精度浮点数 | 8 |  | 0.0 |
| boolean | 布尔型 | 1 | true false | false |
| char | 字符型 | 2 | 0~65535 | '\\u0000' |


> - 整数形数据都被默认为**int**类型，后边加**L/l**则被示为**long**

long e = 2147483648 因为**2147483648**默认为int类型，超出int最大范围，故会报错
> - 任何一个浮点型数据被默认为**double**类型，后边加**F/f**表示**float**
> - 注意：任何一个浮点型容量都比整型大 
> float容量 > long容量
> - char在java中是两个字节，但字符’a‘在windows操作系统中占用一个字节，’中‘在windows操作系统中占用两个字节

**boolean**类型不参与类型转换

## 类型转换
- 第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；

- 第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；

- 第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：**byte < short(char) < int < long < float < double**，其中 short和 char 都占用两个字节，但是char 可以表示更大的正整数；


> 关于float，double容量问题，涉及计算机中浮点数存储的问题

- 第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；

- 第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；

- 第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；

### 自动类型转换

- **小容量**的数据类型可以自动转换为**大容量**的数据类型

### 强制转换

- **大容量**的数据类型转换为**小容量**的数据类型要想编译通过必须加**强制类型转换符（括号中加数据类型）**

> 加了**强制类型转换符**之后，虽然编译通过，但是可能会损失精度


- 当整数型常量没有超过**byte** , **short**，**char**的范围，可以直接赋值
- 当**整数**赋值给**char**，会自动转换为char字符型

## 引用数据类型

- 除了基本数据类型
- String属于引用数据类型
- **所有的类都是引用数据类型**
- 字节数：4

> 缺省默认值=：**null**


# 字符编码

- **ASCII** （‘a’是97 ‘A’是65 ‘0’是48）
- **ISO-8859-1**（latin-1）
- **GB2312**
- **GBK**
- **GB18030**

> 以上三者容量GB2312<GBK<GB18030


- **Big5**
- **unicode**（utf8 utf16 utf32）

# 转义字符
| 转义字符 | 含义 |
| --- | --- |
| \\t | tab键 |
| \\n | 换行 |
| \\' | 普通单引号 |
| \\\\ | 输出 \\ |
| \\u | 表示后边的是一个16进制Unicode编码 |


# 运算相关

- btye，short，char做混和运算的时候，先各自转换为int再运算
- 多种数据类型做混合运算，最终运算结果为**容量最大**的数据类型

## 运算符
| 类型 | 内容 |
| --- | --- |
| 算术运算符 | +、-、*、/、%（取模）、++、-- |
| 关系运算符 | >、>=、<、<=、==、!= |
| 逻辑运算符 | &（逻辑与）、&#124;（逻辑或）、！（逻辑非）、&&（短路与）、&#124;&#124;（短路或） |
| 赋值运算符 | =、+=、-=、*=、/=、%=、^=、&=、&#124;=、<<=、>>= |
| 位运算符 | &（按位与）、&#124;（按位或）、^（按位异或）、~（按位取反）、<<(左移)、>>（带符号右移）、>>>（无符号右移） |
| 条件运算符 | 布尔表达式？表达式1：表达式2（三目） |
| 字符串连接运算符 | + |
| 其他运算符 | instanceof、new |


### &&（短路与） 与 &（逻辑与） 的区别？

- 运算结果上**没有区别**
- 使用 **短路与&&** 的时候，左边的表达式为**false**右边的表达式不执行，这种现象叫**短路现象**。 **短路与**效率高一点。

> 大部分时间都使用**短路与&&** ，需要右边的表达式也执行的时候就需要使用**逻辑与&**


### i += 10 与i = i + 10 的区别

- 只是结果相似，但是并不能说完全相同
- 使用**扩展赋值运算符**（+=等）永远都不会改变运算结果数据类型

```java
byte  x = 12;
x = x + 1;//错误,int类型赋值给byte
x += 1;//没有错误,相当于x = (byet)(x+1)
```

### + 什么时候求和，什么时候字符串拼接？

- **两边都是数字类型**，求和
- **任意一边**是字符串，进行**字符串拼接**

> 字符串拼接之后的结果还是**字符串**


### 自加运算的一个特殊情况

```java
int i=10;
i=i++;
System.out.println(i);//输出是10，但是再c++中则是11

//java中以上代码相当于
int i=10;
int temp=i;
i++;
i=temp;
```

# 类

- 一个java文件中只能有一个**public类**并且这个类的名字和java文件的名字要一致
