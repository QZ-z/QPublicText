语雀密码，stko

# 数据库相关

## 会员业务

会员相关核心数据库表如下：

- `t_user `会员数据表：存储会员账号、密码、证件号、邮箱、手机号等信息
- `t_user_mail `会员邮箱数据表：存储会员邮箱和用户名的关系
- `t_user_phone `会员手机号数据表：存储会员手机号和用户名的关系

## JDBC 和 Proxy 优劣势

JDBC： 

- 优点：性能较高，通过 JDBC 直接向 MySQL 发起请求调用。
- 优点：使用较为简单，理论上无需修改代码，仅需使用 ShardingSphere 的配置即可。
- 缺点：需要修改项目配置以及引入 Jar 包。
- 缺点：对应用的内存有一定影响。

Proxy： 

- 优点：无需对现有项目做任何配置或代码变更，将数据库的地址改为 Proxy 的地址即可。
- 优点：Proxy 对 Java 应用内存没有任何影响。
- 优点：分片后无法知道一条数据记录到底在那张表，Proxy 是屏蔽了分片逻辑，可直接操作逻辑表。
- 缺点：JDBC 操作 MySQL 是点对点的，但是 Proxy 多了一层链路。

为什么选择 ShardingSphere？

- 拥有活跃的社区，能够提供及时的技术支持和更新；
- 代码质量极高，经过严格测试和验证，稳定可靠；
- 提供丰富的功能，满足多样化的业务需求。

## 用户表分库分表策略

根据当前用户表的数据量为 10 亿，并且每年新增 1000 万用户，预估未来系统的生命周期较长，数据量大概会达到 30 亿左右。基于这个数据量，我们预估单表的数据量在 2000 万左右，因此需要分大约 150 张表来容纳这些数据。

2000 万作为一个经验值。这个数据量既不会过小，同时又能保证增删改查等操作相对流畅

### 分片键选择

选择分库分表中的分片键（Sharding Key）是一个关键决策，它直接影响了分库分表的性能和可扩展性。以下是一些选择分片键的关键因素：

1. **访问频率**：选择分片键应考虑数据的访问频率。将经常访问的数据放在同一个分片上，可以提高查询性能和降低跨分片查询的开销。
2. **数据均匀性**：分片键应该保证数据的均匀分布在各个分片上，避免出现热点数据集中在某个分片上的情况。
3. **业务关联性**：分片键应该与业务关联紧密，这样可以避免跨分片查询和跨库事务的复杂性。
4. **数据不可变**：一旦选择了分片键，它应该是不可变的，不能随着业务的变化而频繁修改。

选`username`

### 分片配置

分 2 个库以及对应业务 16 张表

```yaml
# 分片算法
    shardingAlgorithms:
      # 数据库分片算法
      user_database_hash_mod:
        # 根据分片键 Hash 分片
        type: HASH_MOD
        # 分片数量
        props:
          sharding-count: 2
      # 数据表分片算法
      user_table_hash_mod:
        # 根据分片键 Hash 分片
        type: HASH_MOD
        # 分片数量
        props:
          sharding-count: 16
```

# 用户注册模块

## 缓存穿透问题

### 布隆过滤器

![image-20240523235526302](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240523235526302.png)

用多个hash函数计算，将对应的位置置为1

不支持删除：删除当前位置可能会影响其他数据的判断

可能会产生误判，上图再加一个z，如果z经过hash算出来是0、1、4，那么会判断z存在

- 有限二进制位，元素多的时候，误判概率增加
- 如果认为有，可能会误判；如果认为没有，则不会误判

### 布隆+set

![image-20240523235903413](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240523235903413.png)

解决方案：加一个set结构，将注销的`username`放入，然后按着表中流程判断

- 判断存在的话，看看`set`里有没有，有的话说明注销了已经，可以使用
- `set`没有，说明不能使用

> 实际上依然没解决哈希碰撞带来的假阳问题，只是解决了，删除的用户名可以继续使用的问题
>
> 这样牺牲了一些用户名，这些用户名天然不可用

缺点：

- 两次查询，速度慢
- 存储要求大了

解决方案：

- 为防止有人疯狂申请注销加`set`，一个身份证只能注销5次
- 分片来防止`set`过大

### 布隆过滤器大小设置

根据业务场景，选择适合的碰撞率来设计大小，碰撞率有计算公式`位数 = -(元素数量 * ln(期望误报率)) / (ln(2)^2)`，10亿需要内存大概是3.6GB

容量不够：设置定时任务，如果达到初始容量的一定比率，通过后台任务重建布隆过滤器

## 用户注册接口

![image-20240524001459564](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240524001459564.png)

### 责任链设计模式

两种责任链：

- 请求会被 所有的处理器都处理一遍，不存在中途终止的情况，这里参照 MyBatis 拦截器理解，**重点在对请求过程中的数据或者行为进行改变**
- 二则是处理器链执行请求中，某一处理器执行时，如果不符合自制定规则的话，停止流程，并且剩下未执行处理器就不会被执行，大家参照 SpringMvc 拦截器理解。

优点：

- 把总的逻辑拆分，提高代码复用，简化开发
- 添加新的规则不需要改动原有代码，设计新的方法加入责任链即可

缺点：如果处理链过长或者处理时间过长，可能会对系统性能产生一定的影响