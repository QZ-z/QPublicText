语雀密码，stko

# 数据库相关

## 用户管理

会员相关核心数据库表如下：

- `t_user `会员数据表：存储会员账号、密码、证件号、邮箱、手机号等信息
- `t_user_mail `会员邮箱数据表：存储会员邮箱和用户名的关系
- `t_user_phone `会员手机号数据表：存储会员手机号和用户名的关系

会员相关拓展功能表如下：

- `t_user_reuse` 用户名可复用表：存储已被注销的可用用户名
- `t_user_deletion`：用户证件号注销表：存储被注销过得证件号记录数据

![image-20240527194942294](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240527194942294.png)

- `t_passenger`：乘车人数据表，用户与用户乘车人是一对多的关系

![image-20240527195058658](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240527195058658.png)

## 列车管理

`t_train`：列车表，存储每天生成的行驶列车数据。

`t_carriage`：列车车厢表，存储每趟列车对应的车厢数据，包括车厢类型。

`t_train_station `：列车站点表，存储列车行驶站点顺序表。

`t_train_station_relation`：列车站点关联表，存储列车行驶站点关联关系表。

`t_train_station_price`：列车站点价格表，存储列车站点关联关系不同座位价格表。

![image-20240527195353250](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240527195353250.png)

## 订单管理

`t_order`：订单主表，用户购买的单次车票，就对应一个订单。但是有可能一个订单中会有多个乘车人，所以还会有订单明细表。

`t_order_item`：订单明细表，一个订单可能有多个乘车人，多个乘车人就对应多个订单明细。

`t_order_item_passenger`：订单明细乘车人表，因为订单表和订单明细表分库分表规则所致，乘车人无法查看本人车票订单，所以创建了这个关联表。通过证件号关联订单

![image-20240527195647624](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240527195647624.png)

## 支付管理

`t_pay`：订单支付表，存储用户支付车票相关数据

## JDBC 和 Proxy 优劣势

JDBC： 

- 优点：性能较高，通过 JDBC 直接向 MySQL 发起请求调用。
- 优点：使用较为简单，理论上无需修改代码，仅需使用 ShardingSphere 的配置即可。
- 缺点：需要修改项目配置以及引入 Jar 包。
- 缺点：对应用的内存有一定影响。

Proxy： 

- 优点：无需对现有项目做任何配置或代码变更，将数据库的地址改为 Proxy 的地址即可。
- 优点：Proxy 对 Java 应用内存没有任何影响。
- 优点：分片后无法知道一条数据记录到底在那张表，Proxy 是屏蔽了分片逻辑，可直接操作逻辑表。
- 缺点：JDBC 操作 MySQL 是点对点的，但是 Proxy 多了一层链路。

为什么选择 ShardingSphere？

- 拥有活跃的社区，能够提供及时的技术支持和更新；
- 代码质量极高，经过严格测试和验证，稳定可靠；
- 提供丰富的功能，满足多样化的业务需求。

## 用户表分库分表策略

根据当前用户表的数据量为 10 亿，并且每年新增 1000 万用户，预估未来系统的生命周期较长，数据量大概会达到 30 亿左右。基于这个数据量，我们预估单表的数据量在 2000 万左右，因此需要分大约 150 张表来容纳这些数据。

2000 万作为一个经验值。这个数据量既不会过小，同时又能保证增删改查等操作相对流畅

### 分片键选择

选择分库分表中的分片键（Sharding Key）是一个关键决策，它直接影响了分库分表的性能和可扩展性。以下是一些选择分片键的关键因素：

1. **访问频率**：选择分片键应考虑数据的访问频率。将经常访问的数据放在同一个分片上，可以提高查询性能和降低跨分片查询的开销。
2. **数据均匀性**：分片键应该保证数据的均匀分布在各个分片上，避免出现热点数据集中在某个分片上的情况。
3. **业务关联性**：分片键应该与业务关联紧密，这样可以避免跨分片查询和跨库事务的复杂性。
4. **数据不可变**：一旦选择了分片键，它应该是不可变的，不能随着业务的变化而频繁修改。

选`username`

### 分片配置

分 2 个库以及对应业务 16 张表

```yaml
# 分片算法
    shardingAlgorithms:
      # 数据库分片算法
      user_database_hash_mod:
        # 根据分片键 Hash 分片
        type: HASH_MOD
        # 分片数量
        props:
          sharding-count: 2
      # 数据表分片算法
      user_table_hash_mod:
        # 根据分片键 Hash 分片
        type: HASH_MOD
        # 分片数量
        props:
          sharding-count: 16
```

# 用户注册模块

## 缓存穿透问题

### 布隆过滤器

![image-20240523235526302](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240523235526302.png)

用多个hash函数计算，将对应的位置置为1

不支持删除：删除当前位置可能会影响其他数据的判断

可能会产生误判，上图再加一个z，如果z经过hash算出来是0、1、4，那么会判断z存在

- 有限二进制位，元素多的时候，误判概率增加
- 如果认为有，可能会误判；如果认为没有，则不会误判

### 布隆+set

![image-20240523235903413](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240523235903413.png)

解决方案：加一个set结构，将注销的`username`放入，然后按着表中流程判断

- 判断存在的话，看看`set`里有没有，有的话说明注销了已经，可以使用
- `set`没有，说明不能使用

> 实际上依然没解决哈希碰撞带来的假阳问题，只是解决了，删除的用户名可以继续使用的问题
>
> 这样牺牲了一些用户名，这些用户名天然不可用

缺点：

- 两次查询，速度慢
- 存储要求大了

解决方案：

- 为防止有人疯狂申请注销加`set`，一个身份证只能注销5次
- 分片来防止`set`过大

实现部分

![image-20240527194327854](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240527194327854.png)

:question:一开始的删除用户可复用数据是什么意思：解决布隆过滤器不能删除的问题，数据库也存了一份在`t_user_reuse`表中

### 布隆过滤器大小设置

根据业务场景，选择适合的碰撞率来设计大小，碰撞率有计算公式`位数 = -(元素数量 * ln(期望误报率)) / (ln(2)^2)`，10亿需要内存大概是3.6GB

容量不够：设置定时任务，如果达到初始容量的一定比率，通过后台任务重建布隆过滤器

## 用户注册接口

![image-20240524001459564](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240524001459564.png)

### 责任链设计模式

两种责任链：

- 请求会被 所有的处理器都处理一遍，不存在中途终止的情况，这里参照 MyBatis 拦截器理解，**重点在对请求过程中的数据或者行为进行改变**
- 二则是处理器链执行请求中，某一处理器执行时，如果不符合自制定规则的话，停止流程，并且剩下未执行处理器就不会被执行，大家参照 SpringMvc 拦截器理解。

优点：

- 把总的逻辑拆分，提高代码复用，简化开发
- 添加新的规则不需要改动原有代码，设计新的方法加入责任链即可

缺点：如果处理链过长或者处理时间过长，可能会对系统性能产生一定的影响

### 责任链抽象使用

实现多级接口，方便维护一类的`ChainHandler`，即类别通过上层接口获得

```java
public interface AbstractChainHandler<T> extends Ordered {
    
    /**
     * 执行责任链逻辑
     *
     * @param requestParam 责任链执行入参
     */
    void handler(T requestParam);
    
    /**
     * @return 责任链组件标识
     */
    String mark();
}

// 订单创建责任链过滤器
public interface OrderCreateChainFilter<T extends OrderCreateCommand> extends AbstractChainHandler<OrderCreateCommand> {
    
    @Override
    default String mark() {
        return OrderChainMarkEnum.ORDER_CREATE_FILTER.name();
    }
}

// 订单创建参数必填检验
@Component
public final class OrderCreateParamNotNullChainHandler implements OrderCreateChainFilter<OrderCreateCommand> {
    
    @Override
    public void handler(OrderCreateCommand requestParam) {
    	// 逻辑执行
    }
    
    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 路由表设计

采用用户名分表，但是可以使用用户名、邮箱或手机号中的任意一个搭配密码进行登录

防止因为不带用户名造成的读扩散，设计两张路由表：

- 用户手机号表，采用手机号分片
- 用户邮箱表，采用邮箱进行分片

使用手机号查询的时候，先根据手机号拿到用户名，再查用户表

缺点：

- 引入额外查询，性能低
- 维护成本会随着数据量的增加和业务的发展增加

# 列车数据检索