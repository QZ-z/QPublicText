# [Java内存区域详解]()

## [运行时数据区域](https://javaguide.cn/java/jvm/memory-area.html#运行时数据区域)

![image-20240511201557190](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240511201557190.png)

![image-20240511201610797](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240511201610797.png)

:warning: 注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

程序运行中栈可能会出现两种错误：

- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

# 字节码文件

## jvm组成

![image-20240517170010461](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517170010461.png)

- 类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。
- 运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。
- 执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。
- 本地接口：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示

## 字节码文件组成

- **基础信息**：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息
- **常量池**：保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用
- **字段：** 当前类或接口声明的字段信息
- **方法：** 当前类或接口声明的方法信息，核心内容为方法的字节码指令
- **属性：** 类的属性，比如源码的文件名、内部类的列表等

### 基本信息

Magic魔数：每个Java字节码文件的前四个字节是固定的，用16进制表示就是`0xcafebabe`

> 文件都是通过文件头的几个字符判断文件类型的，不是通过文件名称中的后缀名判断的

主副版本号：编译字节码文件时使用的JDK版本号，用于判断当前字节码的版本和运行时的JDK是否兼容

其他

![image-20240517170725158](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517170725158.png)

### 常量池

字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。

字节码指令中通过编号引用到常量池的过程称之为符号引用。

![image-20240519164438397](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519164438397.png)

### 字段

字段中存放的是当前类或接口声明的字段信息，包括了名称，描述符和访问标志

![image-20240519164557025](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519164557025.png)

### 方法

字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容存放在方法的Code属性中

字节码运行时的两个内存区域：

- **操作数栈**是用来存放临时数据的内容，是一个栈式的结构，先进后出。
- **局部变量表**是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量

### 属性

属性主要指的是类的属性，比如源码的文件名、内部类的列表等。

## 字节码工具

### javap

javap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容。

直接输入javap查看所有参数。输入`javap -v` 字节码文件名称 查看具体的字节码信息。如果jar包需要先使用 `jar –xvf` 命令解压。

### jclasslib

可通过插件集成进idea

### Arthas

Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率

![image-20240519165155205](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519165155205.png)

### dump

将字节码文件保存到本地

### jad

将类的字节码文件反编译成源代码，用于确认服务器上的字节码文件是否是最新的

# 类的生命周期

![image-20240519165707788](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519165707788.png)

## 加载

1. 加载(Loading)阶段第一步是类加载器根据【类的全限定名】通过【不同的渠道】以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。

   - 从本地磁盘上获取文件

   - 运行时通过动态代理生成，比如Spring框架

   - Applet技术通过网络获取字节码文件

2. 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到【方法区】中，方法区中生成一个【InstanceKlass对象】，保存类的所有信息，里边还包含实现特定功能比如多态的信息。

![image-20240519165545985](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519165545985.png)

3. Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）

![image-20240519165638519](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519165638519.png)

## 连接

![image-20240519165707788](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519165707788.png)

### 验证

主要目的是检测java字节码文件是否遵守《java虚拟机规范》中的约束，主要有：

1. 文件格式验证，是否以`0xCAFFBABE`开头，版本号是否满足当前jvm的要求
2. 元信息验证，例如类必须有父类（super不为空）
3. 验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置
4. 验证符号引用，例如是否访问了其他类中的private方法

### 准备

准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值。

```Java
public class Student{
	public static int value = 1;
}
```

在准备阶段会为value分配内存并赋初值为0，在【初始化阶段】才会将值修改为1

> final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

### 解析

解析阶段主要是将常量池中的【符号引用】替换为【直接引用】

![image-20240519170215809](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519170215809.png)

![image-20240519170224420](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519170224420.png)

## 初始化

初始化阶段会执行字节码文件中`clinit（class init 类的初始化）`方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值

 ![image-20240519170320542](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519170320542.png)

- `init`方法，会在对象初始化时执行
- `main`方法，主方法
- `clinit`方法，类的初始化阶段执行

类初始化的条件：

1. 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化（在准备阶段直接赋值）

2. 调用`Class.forName(String className)`。

3. new一个该类的对象时。

4. 执行Main方法的当前类。

> 添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类

`clinit`不会执行的几种情况：

1. 无静态代码块且无静态变量赋值语句。

2. 有静态变量的声明，但是没有赋值语句

3. 静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。

> final修饰的变量如果赋值的内容需要执行指令，如`Integer.valueOf(1)`等，才能得出结果，会执行clinit方法进行初始化。

# 类加载器

类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的字节码获取并加载到内存这一部分

## 类加载器分类

java8之前

![image-20240519171606611](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519171606611.png)

## 启动类加载器

- 启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。
- 默认加载Java安装目录`/jre/lib`下的类文件，比如`rt.jar，tools.jar，resources.jar`等

如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：

- **放入`jre/lib`下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。
- **使用参数进行扩展。**推荐，使用`-Xbootclasspath/a:jar包目录/jar包名` 进行扩展，参数中的/a代表新增

## 扩展类加载器和应用程序类加载器

- 扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。
- 它们的源码都位于`sun.misc.Launcher`中，是一个静态内部类。继承自`URLClassLoader`。具备通过目录或者指定jar包将字节码文件加载到内存中。

![image-20240519171943004](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519171943004.png)

`ClassLoader`类定义了具体的行为模式，先从本地或者网络获得字节码文件，然后调用虚拟机底层的方法创建方法区和堆上的对象，这样子类仅需要实现获得字节码部分的代码即可。

### 扩展类加载器

扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录`/jre/lib/ext`下的类文件

通过扩展类加载器去加载用户jar包：

- **放入`/jre/lib/ext`下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容。
- **使用参数进行扩展使用参数进行扩展**。推荐，使用`-Djava.ext.dirs=jar包目录 `进行扩展,这种方式会覆盖掉原始目录，可以用` ;(windows):(macos/linux)`追加上原始目录

###  应用程序加载器

应用程序类加载器会加载`classpath`下的类文件，默认加载的是项目中的类以及通过maven引入的第三方jar包中的类

## JDK9之后的类加载器

JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的`sun.misc.Launcher.java`。

由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。

1. 启动类加载器使用Java编写，位于`jdk.internal.loader.ClassLoaders`类中。

   Java中的`BootClassLoader`继承自`BuiltinClassLoader`实现从模块中找到要加载的字节码资源文件。

   启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。

2. 扩展类加载器被替换成了平台类加载器（Platform Class Loader）。

​     平台类加载器遵循模块化方式加载字节码文件，所以继承关系从`URLClassLoader`变成了`BuiltinClassLoader`，`BuiltinClassLoader`实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。

:question:补充javaguide的部分

# 双亲委派机制

双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，再由顶向下进行加载

![image-20240519172430941](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519172430941.png)

## 双亲委派机制的作用

1. 保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。

2. 避免重复加载。双亲委派机制可以避免同一个类被多次加载。

## 如何指定加载类的类加载器？

在Java中如何使用代码的方式去主动加载一个类呢？

方式1：使用`Class.forName`方法，使用当前类的类加载器去加载指定的类。

方式2：获取到类加载器，通过类加载器的`loadClass`方法指定某个类加载器加载。

## 打破双亲委派机制

- 自定义类加载器并且重写`loadClass`方法。Tomcat通过这种方式实现应用之间类隔离
- 线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。
- Osgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用

> 本质上只有第一种算是真正的打破了双亲委派机制

### 自定义类加载器

`ClassLoader`中包含了4个核心方法，双亲委派机制的核心代码就位于`loadClass`方法中

```Java
public Class<?> loadClass(String name)
类加载的入口，提供了双亲委派机制。内部会调用findClass   重要

protected Class<?> findClass(String name)
由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要

protected final Class<?> defineClass(String name, byte[] b, int off, int len)
做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中

protected final void resolveClass(Class<?> c)
执行类生命周期中的连接阶段
```

可以理解为`loadClass`中定义的是双亲委派机制的逻辑，`findClass`是具体的实现

![image-20240519174537590](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519174537590.png)

![image-20240519174726662](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519174726662.png)

如果父类加载器失败，抛出异常，回到子类加载器的这段代码，这样就实现了加载并向下传递

最后会根据传入的参数判断是否进入连接阶段

:warning:自定义类打破双亲委派机制，主要是重写`loadClass`方法中的逻辑

# 运行时数据区域

![image-20240511201557190](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240511201557190.png)

![image-20240511201610797](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240511201610797.png)

## 程序计数器

程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。

程序计数器不会溢出

## 虚拟机栈

Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行

### 局部变量表

局部变量表的作用是在方法执行过程中存放所有的局部变量。局部变量表分为两种，

1. 一种是字节码文件中的，编译成字节码文件时就可以确定局部变量表的内容
2. 另外一种是栈帧中的也就是保存在内存中。栈帧中的局部变量表是根据字节码文件中的内容生成的

![image-20240519180422628](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519180422628.png)

字节码中的局部变量表依次保存：实例方法的this对象，方法的参数，方法体中声明的局部变量

栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽

![image-20240519180526616](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519180526616.png)

为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。

编译期就可以获得局部变量表的最大槽数，运行中按照这个值创建就行。

### 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值

在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小

### 帧数据

帧数据主要包含动态链接、方法出口、异常表的引用。

#### 动态链接

当前类的字节码指令引用了【其他类的属性或者方法】时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址

动态链接就保存了编号到运行时常量池的内存地址的映射关系

![image-20240519181037975](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519181037975.png)

#### 方法出口

方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址

#### 异常表引用

异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置

![image-20240519181122958](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519181122958.png)

### :warning:栈内存溢出

- **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
- **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss 。

- 语法：-Xss栈大小
- 单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)
- Windows（64位）下的JDK8测试最小值为`180k`，最大值为`1024m`

使用 -XX:ThreadStackSize 调整标志来配置堆栈大小，格式为： `-XX:ThreadStackSize=1024`

## 本地方法栈

Java虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间

## 堆内存

一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。

栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

三个重要参数

![image-20240519181953627](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519181953627.png)

used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存

如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。在实际应用中一般都需要设置total和max的值

要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。

语法：`-Xmx值 -Xms值`

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

限制：`Xmx`必须大于 2 MB，`Xms`必须大于1MB

## 方法区

### 类元信息

方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。

![image-20240519182256764](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519182256764.png)

### 运行时常量池

字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池

![image-20240519182413515](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519182413515.png)

### 字符串常量池

字符串常量池和运行时常量池有什么关系？

早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。

![image-20240519182825623](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519182825623.png)

![image-20240519185104160](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519185104160.png)

左侧是false，右侧是true

`String.intern()`方法是可以手动将字符串放入字符串常量池中

### 方法区的实现

JDK7及之前的版本将方法区存放在【堆区域中的永久代】空间，堆的大小由虚拟机参数来控制`-XX:MaxPermSize=值`。

JDK8及之后的版本将方法区存放在【元空间】中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配，使用`-XX:MaxMetaspaceSize=值`对其大小进行限制

![image-20240519182618852](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519182618852.png)

## 直接内存

直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。

在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:

1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。

2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。

现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。

要创建直接内存上的数据，可以使用`ByteBuffer`

手动调整直接内存的大小，可以使用`XX:MaxDirectMemorySize=大小`，默认不设置该参数情况下，JVM 自动选择 最大分配的大小。

## 静态变量存储的位置

- JDK6及之前的版本中，静态变量是存放在方法区中的，也就是【永久代】。
- JDK7及之后的版本中，静态变量是存放在【堆中的Class对象】中，脱离了永久代。具体源码可参考虚拟机源码：BytecodeInterpreter针对putstatic指令的处理。

# 垃圾回收

## 自动回收和手动回收

- 自动垃圾回收，自动根据对象是否使用由虚拟机来回收对象
  - 优点：降低程序员实现难度、降低对象回收bug的可能性
  - 缺点：程序员无法控制内存回收的及时性
- 手动垃圾回收，由程序员编程实现对象的删除
  - 优点：回收及时性高，由程序员把控回收的时机
  - 缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题

## 方法区的回收

回收的主要内容是不再使用的类，判断一个类可以被卸载的条件是：

1. 此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象
2. 加载该类的类加载器已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用。

开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中

## 判断对象可以回收

### 引用计数法

引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1

缺点：

1. 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

2. 存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。

### 可达性分析法

可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系

可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可被回收

哪些对象被称之为GC Root对象呢？

- 线程Thread对象，引用线程栈帧中的方法参数、局部变量等。
- 系统类加载器加载的java.lang.Class对象，引用类中的静态变量。
- 监视器对象，用来保存同步锁synchronized关键字持有的对象。
- 本地方法调用时使用的全局对象。

> 通过arthas和eclipse Memory Analyzer (MAT) 工具可以查看GC Root，MAT工具是eclipse推出的Java堆内存检测工具

## 常见引用对象

### 强引用

`GCRoot`对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收

### 软引用

软引用：如果一个对象只有软引用关联到它，当【程序内存不足】时，就会将软引用中的数据进行回收

> 在JDK 1.2版之后提供了`SoftReference`类来实现软引用，软引用常用于缓存中，软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉。

软引用对象本身怎么回收呢？

如果软引用对象里边包含的数据已经被回收了，那么软引用对象本身其实也可以被回收了。

`SoftReference`提供了一套队列机制：

1、软引用创建时，通过构造器传入引用队列

2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列

3、通过代码遍历引用队列，将`SoftReference`的强引用删除

### 弱引用

弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收

在JDK 1.2版之后提供了`WeakReference`类来实现弱引用，弱引用主要在`ThreadLocal`中使用。

### 虚引用

虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。

> 常规开发不用

Java中使用`PhantomReference`实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。

## 垃圾回收算法

### 评判标准

![image-20240519214307857](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519214307857.png)

1. 【吞吐量】吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高
2. 【最大暂停时间】最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。最大暂停时间越短，用户使用系统时受到的影响就越短。
3. 【堆使用效率】：不同垃圾回收算法，对堆内存的使用方式是不同的

### 标记清除算法

1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。
2. 清除阶段，从内存中删除没有被标记也就是非存活对象。

优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。

缺点：

1. 碎片化问题。由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。
2. 分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间

### 复制算法

1. 准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。
2. 在垃圾回收GC阶段，将From中存活对象复制到To空间。
3. 将两块空间的From和To名字互换。

优点：

- 吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动
- 不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

缺点：

内存使用效率低，每次只能让一半的内存空间来为创建对象使用。

### 标记整理算法

1. 标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。

2. 整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

优点：

- 内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
- 不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

缺点：

整理阶段的效率不高，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能

### 分代垃圾回收算法

![image-20240519214917375](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519214917375.png)

1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。

2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。

Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。

3、接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。

此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。

4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。

当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。

如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常

对象的特性：

- 系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。
- 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。
- 在虚拟机的默认设置中，新生代大小要远小于老年代的大小。

分代的原因：

1. 可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。
2. 新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。
3. 分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。

## 垃圾回收器

![image-20240519215456414](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519215456414.png)

### 年轻代-Serial垃圾回收器

Serial是是一种单线程串行回收年轻代的垃圾回收器。

![image-20240519215633798](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519215633798.png)

**回收年代和算法：**

年轻代

复制算法

**优点**

单CPU处理器下吞吐量非常出色

**缺点**

多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**

Java编写的客户端程序或者硬件配置有限的场景

### 老年代-SerialOld垃圾回收器

SerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收

`-XX:+UseSerialGC` 新生代、老年代都使用串行回收器。

![image-20240519215633798](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519215633798.png)

**回收年代和算法：**

老年代

标记-整理算法

**优点**

单CPU处理器下吞吐量非常出色

**缺点**

多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**

与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用

### 年轻代-ParNew垃圾回收器

ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收

`-XX:+UseParNewGC `新生代使用ParNew回收器， 老年代使用串行回收器

![image-20240519220702073](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519220702073.png)

**回收年代和算法：**

年轻代

复制算法

**优点**

多CPU处理器下停顿时间较短

**缺点**

吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用

**适用场景**

 JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用

### 老年代- CMS(Concurrent Mark Sweep)垃圾回收器

CMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。

参数：`XX:+UseConcMarkSweepGC`

![image-20240519220841969](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519220841969.png)

CMS执行步骤：

1. 初始标记，用极短的时间标记出GC Roots能直接关联到的对象。

2. 并发标记,   标记所有的对象，用户线程不需要暂停。

3. 重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。

4. 并发清理，清理死亡的对象，用户线程不需要暂停。

**回收年代和算法：**

老年代

标记清除算法

**优点**

系统由于垃圾回收出现的停顿时间较短，用户体验好

**缺点**：

1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用`-XX:CMSFullGCsBeforeCompaction=N `参数（默认0）调整N次Full GC之后再整理。

2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代

**适用场景**

 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等

### 年轻代-Parallel Scavenge垃圾回收器

Parallel Scavenge是JDK8默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。【具备自动调整堆内存大小的特点】。

![image-20240519220702073](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519220702073.png)

**回收年代和算法：**

年轻代

复制算法

**优点**

吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数

**缺点**

不能保证单次的停顿时间

**适用场景**

后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出

**常用参数：**

Parallel Scavenge允许手动设置最大暂停时间和吞吐量。Oracle官方建议在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小。

- 最大暂停时间，`-XX:MaxGCPauseMillis=n` 设置每次垃圾回收时的最大停顿毫秒数
- 吞吐量，`-XX:GCTimeRatio=n` 设置吞吐量为n（用户线程执行时间 = n/n + 1）
- 自动调整内存大小, `-XX:+UseAdaptiveSizePolicy`设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小

### 老年代-Parallel Old垃圾回收器

Parallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。

参数： `-XX:+UseParallelGC ` 或 ` -XX:+UseParallelOldGC`可以使用Parallel Scavenge + Parallel Old这种组合。

![image-20240519220702073](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519220702073.png)

**回收年代和算法：**

老年代

标记-整理算法

**优点**

并发收集，在多核CPU下效率较高

**缺点**

暂停时间会比较长

**适用场景**

与Parallel Scavenge配套使用

### G1垃圾回收器

G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数`-XX:G1HeapRegionSize=32m`指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。

![image-20240519222505726](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519222505726.png)

#### 年轻代回收

年轻代回收（Young GC），回收【Eden区和Survivor区】中不用的对象。会导致STW，G1中可以通过参数`-XX:MaxGCPauseMillis=n`（默认200）  设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。

1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。

![image-20240519222546937](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519222546937.png)

2、标记出Eden和Survivor区域中的存活对象，

3、根据【配置的最大暂停时间】选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。

![image-20240519222600892](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519222600892.png)

> G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。
>
> 比如` -XX:MaxGCPauseMillis=n`（默认200），每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。

4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。

5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。

6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。

![image-20240519222755007](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519222755007.png)

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时

（`-XX:InitiatingHeapOccupancyPercent`默认45%）会触发混合回收MixedGC。回收==所有年轻代和部分老年代的对象以及大对象区==。采用复制算法来完成。

#### 混合回收

混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）

G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。

![image-20240519222848361](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240519222848361.png)

注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。

JDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。

参数1： `-XX:+UseG1GC`  打开G1的开关，JDK9之后默认不需要打开

参数2：`-XX:MaxGCPauseMillis=毫秒值` 最大暂停的时

**回收年代和算法：**

年轻代+老年代

复制算法

**优点**

对比较大的堆如超过6G的堆回收时，延迟可控

不会产生内存碎片

并发标记的SATB算法效率高

**缺点**

JDK8之前还不够成熟

**适用场景**

JDK8最新版本、JDK9之后建议默认使用

### 总结

垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：

JDK8及之前：

ParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1（JDK8之前不建议，较大堆并且关注暂停时间）

JDK9之后:

G1（默认）

# HotSpot对象相关

## 对象的创建

#### [Step1:类加载检查](https://javaguide.cn/java/jvm/memory-area.html#step1-类加载检查)

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、连接和初始化过。如果没有，那必须先执行相应的类加载过程。

#### [Step2:分配内存](https://javaguide.cn/java/jvm/memory-area.html#step2-分配内存)

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**

- 指针碰撞：
  - 适用场合：堆内存规整（即没有内存碎片）的情况下。
  - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
  - 使用该分配方式的 GC 收集器：Serial, ParNew
- 空闲列表：
  - 适用场合：堆内存不规整的情况下。
  - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
  - 使用该分配方式的 GC 收集器：CMS

内存分配的时候会产生线程安全问题 ，虚拟机采用两种方式保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### [Step3:初始化零值](https://javaguide.cn/java/jvm/memory-area.html#step3-初始化零值)

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### [Step4:设置对象头](https://javaguide.cn/java/jvm/memory-area.html#step4-设置对象头)

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### [Step5:执行 init 方法](https://javaguide.cn/java/jvm/memory-area.html#step5-执行-init-方法)

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## [对象的内存布局](https://javaguide.cn/java/jvm/memory-area.html#对象的内存布局)

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）\**和\**对齐填充（Padding）**。

对象头包括两部分信息：

1. 标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。
2. 类型指针（Klass Word）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。**

>  因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全

## [对象的访问定位](https://javaguide.cn/java/jvm/memory-area.html#对象的访问定位)

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：**使用句柄**、**直接指针**。

#### [句柄](https://javaguide.cn/java/jvm/memory-area.html#句柄)

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![image-20240520094515117](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240520094515117.png)

优点：reference中存存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改

#### [直接指针](https://javaguide.cn/java/jvm/memory-area.html#直接指针)

如果使用直接指针访问，reference 中存储的直接就是对象的地址。==java采用这种方式==

![image-20240520094525128](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240520094525128.png)

优点：节省一次定位，节省指针定位的时间开销
