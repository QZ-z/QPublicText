## HTTP/1.1、HTTP/2、HTTP/3 演变

### [#](https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1-相比-http-1-0-提高了什么性能)HTTP/1.1 相比 HTTP/1.0 提高了什么性能？

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

缺点：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

### HTTP/2 做了什么优化？

*1. 头部压缩*

HTTP/2 会**压缩头**（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**（HPACK）

*2. 二进制格式*

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了**二进制格式**，头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧（Headers Frame）和数据帧（Data Frame）**

增加了数据传输效率

*3. 并发传输*

![image-20240515143312433](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515143312433.png)

一个TCP连接包含多个stream

**针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应**

*4、服务器推送*

客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号

一个使用的例子：

- 客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返
- 在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数

:warning:缺点：

- TCP层面的队头阻塞：**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题**

![image-20240515144134212](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515144134212.png)

### HTTP/3 做了哪些优化？

![image-20240515143820161](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515143820161.png)

 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输

QUIC 有以下 3 个特点。

*1、无队头阻塞*

同一条连接上并发传输多个Stream，Stream可以认为是一条HTTP请求

QUIC 有自己的一套机制可以保证传输的可靠性的。**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**

![image-20240515144140049](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515144140049.png)

*2、更快的连接建立*

*3、连接迁移*

##  TCP 基本认识

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-头格式有哪些)TCP 头格式有哪些？

![image-20240515153159577](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515153159577.png)

**序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

**控制位：**

- *ACK*：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
- *RST*：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
- *SYN*：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- *FIN*：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段

###  为什么需要 TCP 协议？ TCP 工作在哪一层？

`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性

需要由上层（传输层）的 `TCP` 协议来负责。

 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的**

### 什么是 TCP ？

- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- **字节流**：
  - 用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。
  - 并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃

###  什么是 TCP 连接？

**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接**

- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

###  如何唯一确定一个 TCP 连接呢？

![image-20240515153424551](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515153424551.png)

源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。

源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

### TCP最大连接数

![image-20240515153453107](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515153453107.png)

当然，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：

- 文件描述符限制

  ，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：

  - **系统级**：当前系统可打开的最大数量，通过 `cat /proc/sys/fs/file-max` 查看；
  - **用户级**：指定用户可打开的最大数量，通过 `cat /etc/security/limits.conf` 查看；
  - **进程级**：单个进程可打开的最大数量，通过 `cat /proc/sys/fs/nr_open` 查看；

- **内存限制**，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。

###  UDP 和 TCP 有什么区别呢？分别的应用场景是？

UDP首部只有 8个字节（64位）

![image-20240515153615074](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515153615074.png)

**TCP 和 UDP 区别：**

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 服务对象*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

*3. 可靠性*

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：[如何基于 UDP 协议实现可靠传输？(opens new window)](https://xiaolincoding.com/network/3_tcp/quic.html)

*4. 拥塞控制、流量控制*

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。

*5. 首部开销*

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销较小。

*6. 传输方式*

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

*7. 分片不同*

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层

**TCP 和 UDP 应用场景：**

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信

### 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有**可变长**的「选项」字段，而 UDP 头部长度则是**不会变化**的

### 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

TCP包长度可以根据`IP总长 - IP首部 - TCP首部`计算得出

但之前的UDP不是基于IP协议发展的，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议。

另一个说法：去掉包长度，首部不是4字节的整数倍了。

### [TCP 和 UDP 可以使用同一个端口吗？](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-和-udp-可以使用同一个端口吗)

可以

在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包

 TCP 和 UDP，在内核中是两个完全独立的软件模块

当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理

![image-20240515155213701](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515155213701.png)

##  TCP 连接建立

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-三次握手过程是怎样的)TCP 三次握手过程是怎样的？

![image-20240515155746474](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515155746474.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

### 如何在 Linux 系统中查看 TCP 状态？

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

### 为什么是三次握手？不是两次、四次？

*原因一：避免历史连接*

三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱**

**如果是两次握手连接，就无法阻止历史连接**，主要原因：**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**

*原因二：同步双方初始序列号*

四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

*原因三：避免资源浪费*

*小结*

TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#为什么每次建立-tcp-连接时-初始化的序列号都要求不一样呢)为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）；
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收； 

### 初始序列号 ISN 是如何随机产生的？

起始 `ISN` 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。

RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。

- `M` 是一个计时器，这个计时器每隔 4 微秒加 1。
- `F` 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。

可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#既然-ip-层会分片-为什么-tcp-层还需要-mss-呢)既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

![image-20240515164145832](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515164145832.png)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节；
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

IP层没有超时重传机制，**如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传**

先进行MSS分片，减少大于MTU的概率，同时丢失了也只用重发MSS单位的数据

### 第一次握手丢失了，会发生什么？

当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**

通常，第一次超时重传是在 1 秒后，**每次超时的时间是上一次的 2 倍**，第5次之后没回应，断开。总耗时63s

###  第二次握手丢失了，会发生什么？

当第二次握手丢失了，客户端和服务端都会重传：

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定；
- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定

###  第三次握手丢失了，会发生什么？

客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态

如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数

> **ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**

### 什么是 SYN 攻击？如何避免 SYN 攻击？

![image-20240515165539981](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515165540121.png)

攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**

避免方式

1. 调大 netdev_max_backlog，该参数调整当网卡接收数据包的速度大于内核处理速度时候保存这些数据包的队列的长度
2. 增大 TCP 半连接队列
3. 开启 net.ipv4.tcp_syncookies，在不使用半连接队列的情况下建立连接
4. 减少 SYN+ACK 重传次数

## TCP 连接断开

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-四次挥手过程是怎样的)TCP 四次挥手过程是怎样的？

![image-20240515193547892](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515193547892.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

### 为什么挥手需要四次？

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接

服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手

### 四次挥手变成三次的情况

当被动关闭方在 TCP 挥手过程中，如果「没有数据要发送」，同时「没有开启 TCP_QUICKACK（默认情况就是没有开启，没有开启 TCP_QUICKACK，等于就是在使用 TCP 延迟确认机制）」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

**所以，出现三次挥手现象，是因为 TCP 延迟确认机制导致的**

### 关闭连接的两种函数

- close 函数，同时 socket 关闭发送方向和读取方向，多线程/进程共享socket，减引用计数，为0才发FIN
- shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向。共享情况下，不管引用计数，直接发FIN

### 第一次挥手丢失了，会发生什么？

超时重传，重传`FIN`报文，次数`tcp_orphan_retries`，每次的重传时间也是上次的二倍

### 第二次挥手丢失了，会发生什么？

ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数

一直没有第三次挥手：

对于 `close` 函数关闭的连接，由于无法再发送和接收数据，所以`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒，超时直接CLOSED

对于`shundown`关闭的，主动关闭方的连接将会一直处于 `FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 shutdown 关闭的连接

### 第三次挥手丢失了，会发生什么？

服务端就会重发 FIN 报文，重发次数`tcp_orphan_retries` 参数控制

### 第四次挥手丢失了，会发生什么？

服务端就会重发 FIN 报文，重发次数`tcp_orphan_retries` 参数控制

### 为什么 TIME_WAIT 等待的时间是 2MSL？

`MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡

**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒**

**2MSL时长** 这其实是相当于**至少允许报文丢失一次**。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对

### 为什么需要 TIME_WAIT 状态？

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
  - 这个时间**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**
- 保证「被动关闭连接」的一方，能被正确的关闭；

### TIME_WAIT 过多有什么危害？

- 第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；
- 第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 `32768～61000`，也可以通过 `net.ipv4.ip_local_port_range`参数指定范围。

### 如何优化 TIME_WAIT？

:one:打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；

开启之后可以**复用处于 TIME_WAIT 的 socket 为新的连接所用**

:two:net.ipv4.tcp_max_tw_buckets

超过这个值，将后面的TIME_WAIT连接状态重置

:three:程序中使用 SO_LINGER ，应用强制使用 RST 关闭。

`l_onoff`为非 0， 且`l_linger`值为 0，那么调用`close`后，会立该发送一个`RST`标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了`TIME_WAIT`状态，直接关闭

### [#](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#服务器出现大量-time-wait-状态的原因有哪些)服务器出现大量 TIME_WAIT 状态的原因有哪些？

根本原因：服务器主动断开了许多TCP连接

==场景一：没有使用长连接==

**根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都是由服务端主动关闭连接**

==场景二：长连接超时==

以ngnix为例

**如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接**

==场景三：长连接请求数量上限==

### 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？

**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**，没有发FIN报文，进入到LAST_ACK状态

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

保活机制：一段时间内没有活动，每隔一个时间间隔，发送探测报文，几个连续的报文都没得到响应，认为当前TCP链接死亡

保活机制时间长，可以应用层实现心跳机制，例如HTTP长连接的超时时间

###  如果已经建立了连接，但是服务端的进程崩溃会发生什么？

连接信息在内核维护，服务端进程崩溃，内核与客户端完成四次挥手断开

### 进程崩溃和宕机

如果「**客户端进程崩溃**」，客户端的进程在发生崩溃的时候，内核会发送 FIN 报文，与服务端进行四次挥手。

但是，「**客户端主机宕机**」，那么是不会发生四次挥手的，具体后续会发生什么？还要看服务端会不会发送数据？

- 如果服务端会发送数据，由于客户端已经不存在，收不到数据报文的响应报文，服务端的数据报文会超时重传，当重传总间隔时长达到一定阈值（内核会根据 tcp_retries2 设置的值计算出一个阈值）后，会断开 TCP 连接；
- 如果服务端一直不会发送数据，再看服务端有没有开启 TCP keepalive 机制？
  - 如果有开启，服务端在一段时间没有进行数据交互时，会触发 TCP keepalive 机制，探测对方是否存在，如果探测到对方已经消亡，则会断开自身的 TCP 连接；
  - 如果没有开启，服务端的 TCP 连接会一直存在，并且一直保持在 ESTABLISHED 状态。

## TCP重传机制

### 超时重传

RTO（Retransmission Timeout 超时重传时间）内没有收到对方的ACK确认应答，重发数据

**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**，由公式计算，动态变化

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送**

缺点：超时周期相对较长

###  快速重传

![image-20240515211923522](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515211923522.png)

缺点：重传的时候无论是重传一个还是多个都不合适（不知道具体重传哪些数据）

### SACK 方法

`SACK`（ Selective Acknowledgment）， **选择性确认**

![image-20240515212134836](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515212134836.png)

优点：将已收到的数据信息发送给发送方，就可以只重传丢失的数据

### Duplicate SACK

Duplicate SACK 又称 `D-SACK`，其主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**

优点：

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

> 能够更好的分析网络丢包的原因

##  TCP滑动窗口

![image-20240515235329131](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515235329131.png)

### 窗口大小由哪一方决定？

接收方决定，发送方窗口不能超过接收方窗口，否则接收方无法正常接手数据。

### 发送方滑动窗口

![image-20240515235427256](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515235427256.png)

![image-20240515235613205](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515235613205.png)

### 接收方的滑动窗口

![image-20240515235718435](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240515235718435.png)

### 滑动窗口的大小变化

接收窗口大小约等于发送窗口大小

滑动窗口动态变化，变化通过TCP中的Windows字段告诉发送方，传输存在延迟

## [#](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#流量控制)TCP流量控制

### 操作系统缓冲区与滑动窗口的关系

发送窗口和接收窗口中存放的字节数，放在操作系统的缓冲区，被操作系统动态调整

应用程序来不及读缓冲区，也会对缓冲区造成影响

### 操作系统的缓冲区，是如何影响发送窗口和接收窗口的呢？

一直来不及读会造成窗口关闭。

如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。

**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**

### 窗口关闭

**如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。**

==窗口关闭的死锁现象==

![image-20240516001549276](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516001549276.png)

==解决潜在的死锁==

![image-20240516001614544](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516001614544.png)

窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接

### 糊涂窗口综合症

如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。

到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。

TCP+IP头部至少有40个字节，传输几个字节就要加上头部，浪费资源。

解决方案：

- 让接收方不通告小窗口给发送方
  - 当「窗口大小」小于 min( MSS，缓存空间/2 ) ，就会向发送方通告窗口为 `0`。等到接收方处理了一些数据后，条件不满足了再打开窗口。

- 让发送方避免发送小数据
  - 使用 Nagle 算法，延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：
    - 条件一：要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`；
    - 条件二：收到之前发送数据的 `ack` 回包；
  - 只开nagle，但是接收方通知小窗口，没用
  - 小数据包交互场景下需要关闭

## [#](https://xiaolincoding.com/network/3_tcp/tcp_feature.html#拥塞控制)TCP拥塞控制

### 与流量控制的区别

- 流量控制避免发送方数据填满接收方缓存，不关注网络中细节
- 拥塞控制为了避免发送方的数据填满整个网络

### 拥塞窗口和滑动窗口

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。`swnd = min(cwnd, rwnd)`，取发送窗口和接收窗口中的最小值

- 没有拥塞`swnd`增大
- 出现拥塞`swnd`减小

### 拥塞判断

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞**

### 拥塞控制算法

#### 慢启动

**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**

![image-20240516004543339](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516004543339.png)

每个报文都有ACK报文，门限理论上指数增长

慢启动门限 `ssthresh` （slow start threshold）状态变量。

- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」

#### 拥塞避免

**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**

![image-20240516004642977](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516004642977.png)

将门限的提升变为线性

#### 拥塞发生

当发生了「超时重传」，则就会使用拥塞发生算法。

这个时候，ssthresh 和 cwnd 的值会发生变化：

- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

cwnd降太多，会造成网络卡顿

发生快速重传，说明收到三次同样的ACK，TCP认为网络没那么拥塞

- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入快速恢复算法

#### 快速恢复

在快速恢复算法前，拥塞窗口已经变为原来的一半，慢启动门限变为拥塞窗口大小。此时

- 拥塞窗口+3（意思是收到了3次ACK）
- 重传丢失的数据包
- 如果再收到重复的ACK，则拥塞窗口大小+1
- 如果收到了新数据的ACK，则可以把拥塞窗口设置为慢启动门限，然后进入拥塞避免算法。

![image-20240516005114387](https://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516005114387.png)

## IP

### IP基础知识

IP 地址（IPv4 地址）由 `32` 位正整数来表示，IP 地址在计算机是以二进制的方式处理的

![image-20240516095942819](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240516095942819.png)

无分类地址CIDR：32 比特的 IP 地址被划分为两部分，前面是**网络号**，后面是**主机号**

IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号「:」隔开

IPv6优点：

- IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配 IP 地址，真是**便捷到即插即用**啊。
- IPv6 包头包首部长度采用固定的值 `40` 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大**提高了传输的性能**。
- IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大**提升了安全性**。

IPv6地址类型：

- 单播地址，用于一对一的通信
  - 在同一链路单播通信，不经过路由器，可以使用**链路本地单播地址**，IPv4 没有此类型
  - 在内网里单播通信，可以使用**唯一本地地址**，相当于 IPv4 的私有 IP
  - 在互联网通信，可以使用**全局单播地址**，相当于 IPv4 的公有 IP
- 组播地址，用于一对多的通信
- 任播地址，用于通信最近的节点，最近的节点是由路由协议决定
- 没有广播地址

![image-20240517163643704](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517163643704.png)

与IPv4首部差异：

- **取消了首部校验和字段。** 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。
- **取消了分片/重新组装相关字段。** 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。（ipv4允许中间路由器分片，但是重组只能在接收端）
- **取消选项字段。** 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 `40` 字节。

### 协议

#### DNS

域名解析，`www.baidu.com`解析为ip地址

![image-20240517163757030](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517163757030.png)

#### ARP

获得下一跳的MAC地址

![image-20240517163834204](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517163834204.png)

ARP请求和ARP响应

RARP 协议正好相反，它是**已知 MAC 地址求 IP 地址**

需要架设一台 `RARP` 服务器，==在这个服务器上注册设备的 MAC 地址及其 IP 地址==。然后再将这个设备接入到网络，接着：

- 该设备会发送一条「我的 MAC 地址是 XXXX，请告诉我，我的 IP 地址应该是什么」的请求信息。
- RARP 服务器接到这个消息后返回「MAC 地址为 XXXX 的设备，IP 地址为 XXXX」的信息给这个设备。

#### DHCP

通过 DHCP 动态获取 IP 地址

![image-20240517164129695](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517164129695.png)

租约的 DHCP IP 地址快过期了，客户端会向服务器发送 DHCP 请求报文，进行续期

使用UDP广播通信，广播不跨局域网，需要DHCP中继代理

![image-20240517164358527](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517164358527.png)

#### NAT

（Network Address Translation，网络地址转换）

转换私有ip为公有ip

实际使用**网络地址与端口转换 NAPT**，将IP地址和端口号一同进行转换

#### ICMP

ICMP 全称是 **Internet Control Message Protocol**，也就是**互联网控制报文协议**。

`ICMP` 主要的功能包括：**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等**

![image-20240517164536963](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517164536963.png)

#### IGMP

管理组播成员

![image-20240517164606655](http://pig-test-qz.oss-cn-beijing.aliyuncs.com/img/image-20240517164606655.png)